# L0 C Backend Design

## Overview

The C backend (`l0_codegen.py`) takes a fully-analyzed `AnalysisResult` and emits portable C (C99) code.

## Design Principles

1. **Portable C**: No compiler-specific extensions; targets standard C99
2. **Type safety layer**: All L0 types map to explicit C typedefs
3. **Readable output**: Generated code should be debuggable and understandable
4. **No undefined behavior**: Follow the same UB-free principles as the language

## Type Mapping

### Builtins

L0 types map to C typedefs, defined in the runtime header (`l0_runtime.h`):

```c
typedef int32_t l0_int;

typedef uint8_t l0_bool;

typedef struct {
    const char* data;  /* Pointer to character data (may be NULL for empty string) */
    l0_int len;        /* Length in bytes (must be >= 0) */
} l0_string;
```

### Structs

L0 structs map directly to C structs:

```l0
module main;

struct Point {
    x: int;
    y: int;
}
```

↓

```c
struct l0_main_Point {
    l0_int x;
    l0_int y;
};
```

### Enums (Tagged Unions)

L0 enums become tagged unions in C:

```l0
module main;

enum Expr {
    Int(value: int);
    Add(left: Expr*, right: Expr*);
}
```

↓

```c
enum l0_main_Expr_tag {
    l0_main_Expr_Int,
    l0_main_Expr_Add,
};

struct l0_main_Expr {
    enum l0_main_Expr_tag tag;
    union {
        struct { l0_int value; } Int;
        struct { struct l0_main_Expr left; struct l0_main_Expr right; } Add;
    } data;
};
```

### Pointers and Nullability

- `T*` → `T*` in C (NULL not allowed)
- `T*?` → `T*` in C with `NULL` allowed (UB-free semantics enforced via frontend checks and/or runtime panics as needed)
- `T?` (non-pointer nullable) → struct wrapper `{ bool has_value; T value; }`.

## Name Mangling

To avoid C namespace collisions, we mangle names:

- Structs: `l0_{module}_{name}` (e.g., `l0_app_main_Point`)
- Enums: `l0_{module}_{name}` (e.g., `l0_expr_Expr`)
- Functions: `l0_{module}_{name}` (e.g., `l0_app_main_add`)
    - Exception: The entry module's `main` function stays as `main`

Module dots are replaced with underscores: `app.main` → `app_main`

## Statement Lowering

### Let statements

```l0
let x: int = 5;
```

↓

```c
l0_int x = 5;
```

### Match statements

Match becomes a switch on the tag field:

```l0
    match (e) {
        Int(value) => {
            return value;
        }
        Add(left, right) => {
            return eval(left) + eval(right);
        }
    }
```

↓

```c
{
    struct l0_main_Expr _scrutinee = e;
    switch (_scrutinee.tag) {
    case l0_main_Expr_Int: {
        l0_int value = _scrutinee.data.Int.value;
        return value;
        break;
    }
    case l0_main_Expr_Add: {
        struct l0_main_Expr left = _scrutinee.data.Add.left;
        struct l0_main_Expr right = _scrutinee.data.Add.right;
        return (l0_main_eval(left) + l0_main_eval(right));
        break;
    }
    }
}
```

### Control flow

- `if` / `else` → direct C equivalents
- `while` → direct C equivalent
- `return` → direct C equivalent

## Expression Lowering

Most expressions map directly:

- Literals: `42` → `42`, `true` → `1`, `"hello"` → `"hello"`
- Binary ops: `a + b` → `(a + b)`
- Unary ops: `-x` → `(-x)`
- Calls: `f(x, y)` → `l0_main_f(x, y)` (with mangled names)
- Field access: `p.x` → `p.x` or `p->x` depending on pointer type
- Cast: `x as T` → `((T)(x))` for primitive types, or appropriate struct wrapping/unwrapping for nullable types.

### Struct/enum constructors

Constructor syntax like `Point(1, 2)` or `Int(42)` are lowered to explicit initialization:

```c
struct l0_module_Point p = { .x = 1, .y = 2 };

struct l0_module_Expr e = {
    .tag = l0_module_Expr_Int,
    .data = { .Int = { .value = 42 } }
};
```

## Code Organization

### Generated file structure

```c
/* Generated by L0 compiler */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

/* L0 runtime header */
#include "l0_runtime.h"

/* Forward declarations */
struct l0_main_Point;
...

/* Struct definitions */
struct l0_main_Point {
    l0_int x;
    l0_int y;
};
...

/* Enum definitions (tagged unions) */
...

/* Function declarations */
l0_int l0_main_main(void);
...

/* Function definitions */
struct l0_main_Point l0_main_add(struct l0_main_Point p1, struct l0_main_Point p2) {
    struct l0_main_Point p = (struct l0_main_Point){ .x = ((p1).x + (p2).x), .y = ((p1).y + (p2).y) };
    return p;
}

l0_int l0_main_main(void) {
    /* ... function body ... */
    return 0;
}

...

/* C entry point wrapper */
int main(void) {
    return (int) l0_main_main();
}
...
```

## Current Limitations

The initial implementation has several limitations to be addressed:

### 1. String escaping

String literals need proper C escaping for quotes, newlines, etc.

At the moment, strings are output as-is, which means they rely on the C compiler to handle invalid characters.

### 3. Module imports

Currently, emits everything in one file. Need to handle:

- Multi-module projects with proper includes
- Header/implementation file split

### 4. Extern function handling

Extern functions names are not mangled so they can link with the C kernel.
Need to:

- Consider extern "C" declarations for functions not in the C kernel.
- Handle calling conventions when needed (e.g, l0_string → const char*)

### 5. Nullable semantics

Currently `T?` just maps to `T*` and `T*?` to `T*` as well. This is probably insufficient.

- Use raw pointers with null checks?
- Use wrapper structs with validity flags?
- Document the NULL = none convention clearly

### 7. Function name resolution in calls

Currently, assumes direct function names. Need to:

- Potentially support function pointers

## Testing Strategy

### Unit tests

- Test type emission for all type forms
- Test statement lowering for each statement kind
- Test expression lowering for all operators
- Test name mangling edge cases

### Integration tests

- Generate C code for simple programs
- Compile with gcc/clang
- Run and verify output
- Test with TinyCC for portability

### Example programs to test

- Simple arithmetic (no dependencies)
- Struct creation and field access
- Enum creation and pattern matching
- Recursive functions (tree traversal)
- Multi-module program with imports

## Design Decisions

### Single-file vs multi-file output

**Decision**: Start with single-file output for simplicity.

- Easier to implement and test
- Sufficient for small programs
- Can split later when needed

### Name mangling strategy

**Decision**: Use `l0_{module}_{name}` with underscores.

- Simple and predictable
- Avoids most collisions
- Easy to reverse-engineer from C
- Consider shorter scheme if names get too long
- Avoid C keywords by appending `__v` if needed

### Tagged union representation

**Decision**: Standard C tagged union approach.

- Portable and well-understood
- Efficient (no extra indirection)
- Easy to debug
- Matches common C practice

### Match statement lowering

**Decision**: Switch on tag with explicit bindings.

- Straightforward translation
- Compiler can optimize switch
- Clear correspondence to source
- Exhaustiveness checked by L0 frontend

# L0 C Backend Implementation

**C Code Generator** (`l0_codegen.py`) - Emits C99 code from analyzed programs

## Backend Usage

The `CBackend` class takes an `AnalysisResult` and produces C source code:

```python
from l0_driver import L0Driver
from l0_codegen import CBackend

# Analyze L0 program
driver = L0Driver()
result = driver.analyze("my_module")

# Generate C code
if not result.has_errors():
    backend = CBackend(result)
    c_code = backend.generate()
    print(c_code)
```

## Key Features Implemented

### Type System

- Builtin types (`int`, `bool`, `string`, `void`)
- Structs with fields
- Enums with payloads (as tagged unions)
- Pointers (single and multiple levels)
- Nullable types
- Function types

### Statements

- Let bindings with type inference
- Assignments
- If/else conditionals
- While loops
- Return statements
- Match statements (lowered to switch)

### Expressions

- Literals (int, bool, string)
- Variables
- Binary operators (+, -, *, /, <, >, ==, !=, &&, ||, etc.)
- Unary operators (-, !, *)
- Function calls
- Field access (. and -> in C)
- Casts
- Parenthesized expressions
- Struct/Enum Constructors - Syntax for `Point(1, 2)` or `Int(42)` lowered to explicit initialization
- String Escaping - String literals use C escaping
- Function Name Resolution - Calls use mangled names
- Nullable Semantics - `T?` handled as `T*` with null checks (T*? mapped to T* for now)

### Name Mangling

- Struct names: `l0_{module}_{name}`
- Enum names: `l0_{module}_{name}`
- Function names: `l0_{module}_{name}`
- Entry point `main` is also mangled and wrapped by C `main`, taking care of the L0 return type (void or int).

## What's Missing (Known Limitations)

### Important for Real Programs

- **Multi-module Support** - Currently single-file output only
- **Extern "C" Functions** - Need to link with external C libraries
- **Proper Nullable Handling** - More robust representation of nullable types

### Nice to Have

- **Debug Line Directives** - For source-level debugging
- **Better Error Recovery** - Handle partially-typed programs gracefully
- **Code Formatting** - More readable output with comments

## Future Considerations

### Optimization opportunities

- Inline small functions
- Eliminate dead code
- Constant folding (if not done earlier)
- Tail call optimization for recursion

### Debug information

- Emit `#line` directives for error tracing
- Keep correspondence between L0 and C code
- Source maps for debuggers

### Alternative targets in the future

- Consider LLVM IR for better optimization
- WebAssembly for browser deployment
- Keep C backend as stable, portable option

## Conclusion

The L0 compiler now has:

1. Complete frontend (lexer → parser → semantic analysis)
2. C backend (code generation)
3. Clear path forward for remaining features

The backend is **functional**.

The next steps focus on filling in missing features, improving robustness, and integrating with the CLI for ease of use.
