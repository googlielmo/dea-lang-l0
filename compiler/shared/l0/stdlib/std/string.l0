/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025-2026 gwz
 */

/**
 * Standard library module for string operations.
 *
 * This module provides basic string manipulation functions such as
 * length retrieval, character access, comparison, concatenation,
 * and slicing.
 */
module std.string;

import sys.rt;

import std.assert;

/* -------------------------------------
   Basic string operations
   ------------------------------------ */

// Returns the length of the given string.
func len_s(s: string) -> int {
    return rt_strlen(s);
}

// Returns the character code (0-255) at the specified index in the string.
func char_at_s(s: string, index: int) -> byte {
    return rt_string_get(s, index);
}

// Compares two strings for equality.
func eq_s(a: string, b: string) -> bool {
    return rt_string_equals(a, b);
}

// Compares two strings lexicographically.
func cmp_s(a: string, b: string) -> int {
    return rt_string_compare(a, b);
}

// Concatenates two strings and returns the result.
func concat_s(a: string, b: string) -> string {
    return rt_string_concat(a, b);
}

// Returns a slice of the string from start to end (exclusive).
func slice_s(s: string, start: int, end: int) -> string {
    return rt_string_slice(s, start, end);
}

func byte_to_s(b: byte) -> string {
    return rt_string_from_byte(b);
}

func bytes_to_s(bytes: byte*, len: int) -> string {
    return rt_string_from_byte_array(bytes, len);
}

// Returns the index of the first occurrence of 'needle' in 'haystack', or -1 if not found.
func find_s(haystack: string, needle: string) -> int {
    return find_from_s(haystack, needle, 0);
}

// Returns the index of the first occurrence of 'needle' in 'haystack' starting from 'pos', or -1 if not found.
func find_from_s(haystack: string, needle: string, pos: int) -> int {
    assert(pos >= 0, "find_from_s: position must be non-negative");
    let haystack_len = len_s(haystack);
    let needle_len = len_s(needle);
    if (pos > haystack_len - needle_len) {
        return -1;
    }
    for (let i = pos; i <= haystack_len - needle_len; i = i + 1) {
        let found = true;
        for (let j = 0; j < needle_len; j = j + 1) {
            if (char_at_s(haystack, i + j) != char_at_s(needle, j)) {
                found = false;
                break;
            }
        }
        if (found) {
            return i;
        }
    }
    return -1;
}

// Returns true if 'haystack' contains 'needle'.
func contains_s(haystack: string, needle: string) -> bool {
    return find_s(haystack, needle) != -1;
}

// Returns true if 's' starts with 'prefix'.
func starts_with_s(s: string, prefix: string) -> bool {
    return find_s(s, prefix) == 0;
}

// Returns true if 's' ends with 'suffix'.
func ends_with_s(s: string, suffix: string) -> bool {
    let s_len = len_s(s);
    let suffix_len = len_s(suffix);
    if (suffix_len > s_len) {
        return false;
    }
    return find_from_s(s, suffix, s_len - suffix_len) == s_len - suffix_len;
}

/* -------------------------------------
   Character classification
   ------------------------------------ */

func is_space(c: byte) -> bool {
    return c == ' ' || c == '\n' || c == '\t' || c == '\r';
}

func is_digit(c: byte) -> bool {
    return c >= '0' && c <= '9';
}

func is_digit_base(c: byte, base: int) -> bool {
    assert(base >= 2 && base <= 16, "Base must be between 2 and 16");

    if (base <= 10) {
        return c >= '0' && c < ('0' + base);
    }

    if (c >= '0' && c <= '9') {
        return true;
    }

    if (c >= 'a' && c < ('a' + base - 10)) {
        return true;
    }

    if (c >= 'A' && c < ('A' + base - 10)) {
        return true;
    }

    return false;
}

func is_alpha(c: byte) -> bool {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

func is_alnum(c: byte) -> bool {
    return is_alpha(c) || is_digit(c);
}

/* -------------------------------------
   Character manipulation
   ------------------------------------ */

func to_digit(c: byte) -> int {
    return c - '0';
}

func to_digit_base(c: byte, base: int) -> int? {
    assert(base >= 2 && base <= 16, "Base must be between 2 and 16");

    if (base <= 10) {
        if (is_digit(c) && c < ('0' + base)) {
            return to_digit(c);
        }
        return null;
    }

    if (c >= '0' && c <= '9') {
        return to_digit(c);
    }

    if (c >= 'a' && c < ('a' + base - 10)) {
        return 10 + (c - 'a');
    }

    if (c >= 'A' && c < ('A' + base - 10)) {
        return 10 + (c - 'A');
    }

    return null;
}

func to_upper(c: byte) -> byte {
    if (c >= 'a' && c <= 'z') {
        return (c - ('a' - 'A')) as byte;
    }
    return c;
}

func to_lower(c: byte) -> byte {
    if (c >= 'A' && c <= 'Z') {
        return (c + ('a' - 'A')) as byte;
    }
    return c;
}

/* -------------------------------------
   String manipulation and conversion
   ------------------------------------ */

/*
 * trim_s removes leading and trailing whitespace from the input string.
 */
func trim_s(s: string) -> string {
    let start: int = 0;
    let end: int = len_s(s) - 1;
    while (start <= end && is_space(char_at_s(s, start))) {
        start = start + 1;
    }
    while (end >= start && is_space(char_at_s(s, end))) {
        end = end - 1;
    }
    if (start > end) {
        return "";
    }
    return slice_s(s, start, end + 1);
}

func digit_to_char(d: int) -> byte {
    if (d < 10) {
        return ('0' + d) as byte;
    }
    return ('a' + d - 10) as byte;
}
