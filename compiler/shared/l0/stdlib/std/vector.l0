/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025-2026 gwz
 */

module std.vector;

import sys.rt;
import sys.unsafe;

import std.assert;
import std.string;

import std.array;

/* ------------------------------------
   Vector: Dynamic Array Implementation
   ------------------------------------ */

/*
 * VectorBase implements a dynamic array (vector) of elements of a given size.
 * It uses ArrayBase internally to manage storage.
 * It can grow dynamically as elements are added, and a capacity can be reserved in advance.
 *
 * Note: This is a low-level implementation and does not provide type safety.
 * It is the caller's responsibility to manage types and casting.
 */
struct VectorBase {
    arr: ArrayBase*;
    length: int;
}

func vec_create(element_size: int, initial_capacity: int) -> VectorBase* {
    assert(element_size > 0, "Element size must be greater than 0 for vector creation");
    let arr = arr_create(element_size, initial_capacity);
    let self = new VectorBase(arr, 0);
    return self;
}

func vec_grow(self: VectorBase*) {
    assert(self.length <= self.arr.capacity, "Vector invariant violated in vec_grow");
    if (self.length == self.arr.capacity) {
        let next_capacity = self.arr.capacity;
        if (next_capacity == 0) {
            next_capacity = 1;
        } else {
            next_capacity = next_capacity * 2;
        }
        arr_resize(self.arr, next_capacity);
    }
    self.length = self.length + 1;
}

func vec_reserve(self: VectorBase*, total_capacity: int) {
    if (total_capacity > self.arr.capacity) {
        arr_resize(self.arr, total_capacity);
    }
}

func vec_check(self: VectorBase*, index: int) {
    arr_check(self.arr, index);
}

func vec_get(self: VectorBase*, index: int) -> void* {
    return arr_get(self.arr, index);
}

func vec_push(self: VectorBase*) -> void* {
    vec_grow(self);
    return vec_get(self, self.length - 1);
}

func vec_size(self: VectorBase*) -> int {
    return self.length;
}

func vec_capacity(self: VectorBase*) -> int {
    return self.arr.capacity;
}

func vec_zap(self: VectorBase*, index: int) {
    arr_zap(self.arr, index);
}

func vec_clear(self: VectorBase*) {
    /* Reset capacity to 1, length to 0 */
    arr_resize(self.arr, 1);
    self.length = 0;
}

func vec_free(self: VectorBase*) {
    arr_free(self.arr);
    drop self;
}

/* ------------------------------------
   Vector specialized push functions
   ------------------------------------ */

func vec_push_int(self: VectorBase*, val: int) {
    assert(self.arr.element_size == sizeof(int), "Element size mismatch in vec_push_int");
    let dest = vec_push(self) as int*;
    *dest = val;
}

func vec_push_byte(self: VectorBase*, val: byte) {
    assert(self.arr.element_size == sizeof(byte), "Element size mismatch in vec_push_byte");
    let dest = vec_push(self) as byte*;
    *dest = val;
}

func vec_push_bool(self: VectorBase*, val: bool) {
    assert(self.arr.element_size == sizeof(bool), "Element size mismatch in vec_push_bool");
    let dest = vec_push(self) as bool*;
    *dest = val;
}

func vec_push_ptr(self: VectorBase*, val: void*) {
    assert(self.arr.element_size == sizeof(void*), "Element size mismatch in vec_push_ptr");
    let dest = vec_push(self) as void**;
    *dest = val;
}

// Insertion sort on VectorBase with int elements (ascending).
func vi_sort(self: VectorBase*) {
    assert(self.arr.element_size == sizeof(int), "Element size mismatch in vi_sort");
    let n = vec_size(self);
    if (n <= 1) {
        return;
    }

    for (let i = 1; i < n; i = i + 1) {
        let key = *(vec_get(self, i) as int*);
        let j = i - 1;

        while (j >= 0) {
            let cur_ptr = vec_get(self, j) as int*;
            if (!(key < *cur_ptr)) {
                break;
            }
            let dst_ptr = vec_get(self, j + 1) as int*;
            *dst_ptr = *cur_ptr;
            j = j - 1;
        }

        let ins_ptr = vec_get(self, j + 1) as int*;
        *ins_ptr = key;
    }
}

/* ------------------------------------
   String Vector specialization
   ------------------------------------ */

type VectorString = VectorBase;

func vs_create(initial_capacity: int) -> VectorString* {
    return vec_create(sizeof(string), initial_capacity);
}

func vs_push(self: VectorString*, val: string) {
    let dest = vec_push(self) as string*;
    *dest = val;
}

func vs_get(self: VectorString*, index: int) -> string {
    let src = vec_get(self, index) as string*;
    return *src;
}

func vs_size(self: VectorString*) -> int {
    return vec_size(self);
}

func vs_capacity(self: VectorString*) -> int {
    return vec_capacity(self);
}

func _vs_less(a: string, b: string) -> bool {
    return rt_string_compare(a, b) < 0;
}

// Insertion sort on VectorString (lexicographic, ascending).
func vs_sort(self: VectorString*) {
    let n = vec_size(self);
    if (n <= 1) {
        return;
    }

    for (let i = 1; i < n; i = i + 1) {
        let key = vs_get(self, i);
        let j = i - 1;

        while (j >= 0) {
            let cur = vs_get(self, j);
            if (!_vs_less(key, cur)) {
                break;
            }
            let dst_ptr = vec_get(self, j + 1) as string*;
            *dst_ptr = cur;
            j = j - 1;
        }

        let ins_ptr = vec_get(self, j + 1) as string*;
        *ins_ptr = key;
    }
}

func vs_clear(self: VectorString*) {
    for (let i: int = 0; i < vec_size(self); i = i + 1) {
        let str_ptr = vec_get(self, i) as string*;
        rt_string_release(*str_ptr);
    }
    vec_clear(self);
}

func vs_free(self: VectorString*) {
    for (let i: int = 0; i < vec_size(self); i = i + 1) {
        let str_ptr = vec_get(self, i) as string*;
        rt_string_release(*str_ptr);
    }
    vec_free(self);
}
