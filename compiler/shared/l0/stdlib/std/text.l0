/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025-2026 gwz
 */

module std.text;

import std.string;
import std.math;
import std.assert;

import std.vector;

/* -------------------------------------
   StringBuffer for efficient string building
   ------------------------------------ */

struct StringBuffer {
    parts: VectorString*; // Vector of strings
    size: int; // Total size of all parts (cached for efficiency)
}

func sb_create() -> StringBuffer* {
    let parts = vs_create(8);
    let self = new StringBuffer(parts, 0);
    return self;
}

func sb_append(self: StringBuffer*, s: string) {
    vs_push(self.parts, s);
    self.size = self.size + len_s(s);
}

func sb_append_int(self: StringBuffer*, value: int) {
    sb_append(self, int_to_string(value));
}

func sb_append_byte(self: StringBuffer*, b: byte){
    sb_append(self, byte_to_s(b));
}

func sb_to_string(self: StringBuffer*) -> string {
    with (let cb = cb_create() => cb_free(cb)) {
        cb_reserve(cb, self.size);
        for (let i: int = 0; i < vs_size(self.parts); i = i + 1) {
            cb_append_s(cb, vs_get(self.parts, i));
        }
        return cb_to_string(cb);
    }
}

func sb_size(self: StringBuffer*) -> int {
    return self.size;
}

func sb_free(self: StringBuffer*) {
    vs_free(self.parts);
    drop self;
}

/* ------------------------------------
   CharBuffer for efficient string building
   ------------------------------------ */

struct CharBuffer {
    chars: VectorBase*; // Vector of byte
}

func cb_create() -> CharBuffer* {
    let chars = vec_create(sizeof(byte), 16);
    let self = new CharBuffer(chars);
    return self;
}

func cb_capacity(self: CharBuffer*) -> int {
    return vec_capacity(self.chars);
}

func cb_size(self: CharBuffer*) -> int {
    return vec_size(self.chars);
}

func cb_reserve(self: CharBuffer*, total_capacity: int) {
    vec_reserve(self.chars, total_capacity);
}

func cb_append(self: CharBuffer*, c: byte) {
    let dest = vec_push(self.chars) as byte*;
    *dest = c;
}

func cb_append_s(self: CharBuffer*, s: string) {
    for (let i: int = 0; i < len_s(s); i = i + 1) {
        let c = char_at_s(s, i);
        cb_append(self, c);
    }
}

func cb_append_slice(self: CharBuffer*, s: string, start: int, length: int) {
    for (let i: int = 0; i < length; i = i + 1) {
        let c = char_at_s(s, start + i);
        cb_append(self, c);
    }
}

func cb_append_int(self: CharBuffer*, value: int) {
    cb_append_s(self, int_to_string(value));
}

func cb_reverse(cb: CharBuffer*) {
    let size = cb_size(cb);
    for (let i: int = 0; i < size / 2; i = i + 1) {
        let a = vec_get(cb.chars, i) as byte*;
        let b = vec_get(cb.chars, size - 1 - i) as byte*;
        let temp = *a;
        *a = *b;
        *b = temp;
    }
}

func cb_to_string(self: CharBuffer*) -> string {
    let size = cb_size(self);
    let bytes = vec_get(self.chars, 0) as byte*;
    return bytes_to_s(bytes, size);
}

func cb_clear(self: CharBuffer*) {
    vec_clear(self.chars);
}

func cb_free(self: CharBuffer*) {
    vec_free(self.chars);
    drop self;
}

/* ------------------------------------
   Additional string utility functions
   ------------------------------------ */

/*
 * concat3_s concatenates three strings and returns the result.
 */
func concat3_s(a: string, b: string, c: string) -> string {
    let total_len = len_s(a) + len_s(b) + len_s(c);
    if (total_len == 0) {
        return "";
    }
    with (let cb = cb_create() => cb_free(cb)) {
        cb_reserve(cb, total_len);
        cb_append_s(cb, a);
        cb_append_s(cb, b);
        cb_append_s(cb, c);
        return cb_to_string(cb);
    }
}

/*
 * concat4_s concatenates four strings and returns the result.
 */
func concat4_s(a: string, b: string, c: string, d: string) -> string {
    let total_len = len_s(a) + len_s(b) + len_s(c) + len_s(d);
    if (total_len == 0) {
        return "";
    }
    with (let cb = cb_create() => cb_free(cb)) {
        cb_reserve(cb, total_len);
        cb_append_s(cb, a);
        cb_append_s(cb, b);
        cb_append_s(cb, c);
        cb_append_s(cb, d);
        return cb_to_string(cb);
    }
}

/*
 * to_upper_s converts all characters in the input string to uppercase.
 */
func to_upper_s(s: string) -> string {
    with (let cb = cb_create() => cb_free(cb)) {
        for (let i: int = 0; i < len_s(s); i = i + 1) {
            let c = char_at_s(s, i);
            cb_append(cb, to_upper(c));
        }
        return cb_to_string(cb);
    }
}

/*
 * to_lower_s converts all characters in the input string to lowercase.
 */
func to_lower_s(s: string) -> string {
    with (let cb = cb_create() => cb_free(cb)) {
        for (let i: int = 0; i < len_s(s); i = i + 1) {
            let c = char_at_s(s, i);
            cb_append(cb, to_lower(c));
        }
        return cb_to_string(cb);
    }
}

/*
 * repeat_s returns a new string that is the input string `s` repeated `count` times.
 */
func repeat_s(s: string, count: int) -> string {
    with (let cb = cb_create() => cb_free(cb)) {
        for (let i: int = 0; i < count; i = i + 1) {
            cb_append_s(cb, s);
        }
        return cb_to_string(cb);
    }
}

func int_to_string_base(value: int, base: int) -> string {
    assert(base >= 2 && base <= 16, "Base must be between 2 and 16");
    if (value == 0) {
        return "0";
    }
    let sign = 1;
    if (value < 0) {
        sign = -1;
    }

    let cb = cb_create();

    let digit = emod(value, base);
    if (sign < 0 && digit != 0) {
        digit = base - digit;
    }
    cb_append(cb, digit_to_char(digit));
    value = value / (sign * base); // divide with sign adjustment

    while (value != 0) {
        digit = emod(value, base);
        cb_append(cb, digit_to_char(digit));
        value = value / base;
    }
    if (sign < 0) {
        cb_append(cb, '-' as byte);
    }

    cb_reverse(cb);
    let result = cb_to_string(cb);
    cb_free(cb);
    return result;
}

func reverse_s(s: string) -> string {
    with (let cb = cb_create() => cb_free(cb)) {
        cb_append_s(cb, s);
        cb_reverse(cb);
        return cb_to_string(cb);
    }
}

func int_to_string(value: int) -> string {
    return int_to_string_base(value, 10);
}

func int_to_hex_string(value: int) -> string {
    return int_to_string_base(value, 16);
}

func int_to_bin_string(value: int) -> string {
    return int_to_string_base(value, 2);
}
