/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025-2026 gwz
 */

/**
 * Standard library module for string operations.
 *
 * This module provides basic string manipulation functions such as
 * length retrieval, character access, comparison, concatenation,
 * and slicing.
 */
module std.string;

import sys.rt;

import std.assert;

/* -------------------------------------
   Basic string operations
   ------------------------------------ */

// Returns the length of the given string.
func len_s(s: string) -> int {
    return rt_strlen(s);
}

// Returns the character code (0-255) at the specified index in the string.
func char_at_s(s: string, index: int) -> byte {
    return rt_string_get(s, index);
}

// Compares two strings for equality.
func eq_s(a: string, b: string) -> bool {
    return rt_string_equals(a, b);
}

// Concatenates two strings and returns the result.
func concat_s(a: string, b: string) -> string {
    return rt_string_concat(a, b);
}

// Returns a slice of the string from start to end (exclusive).
func slice_s(s: string, start: int, end: int) -> string {
    return rt_string_slice(s, start, end);
}

func byte_to_s(b: byte) -> string {
    return rt_string_from_byte(b);
}

func bytes_to_s(bytes: byte*, len: int) -> string {
    return rt_string_from_byte_array(bytes, len);
}

// Returns the index of the first occurrence of 'needle' in 'haystack', or -1 if not found.
func find_s(haystack: string, needle: string) -> int {
    return find_from_s(haystack, needle, 0);
}

// Returns the index of the first occurrence of 'needle' in 'haystack' starting from 'pos', or -1 if not found.
func find_from_s(haystack: string, needle: string, pos: int) -> int {
    assert(pos >= 0, "find_from_s: position must be non-negative");
    let haystack_len = len_s(haystack);
    let needle_len = len_s(needle);
    if (pos > haystack_len - needle_len) {
        return -1;
    }
    for (let i = pos; i <= haystack_len - needle_len; i = i + 1) {
        let found = true;
        for (let j = 0; j < needle_len; j = j + 1) {
            if (char_at_s(haystack, i + j) != char_at_s(needle, j)) {
                found = false;
                break;
            }
        }
        if (found) {
            return i;
        }
    }
    return -1;
}

// Returns true if 'haystack' contains 'needle'.
func contains_s(haystack: string, needle: string) -> bool {
    return find_s(haystack, needle) != -1;
}

// Returns true if 's' starts with 'prefix'.
func starts_with_s(s: string, prefix: string) -> bool {
    return find_s(s, prefix) == 0;
}

// Returns true if 's' ends with 'suffix'.
func ends_with_s(s: string, suffix: string) -> bool {
    let s_len = len_s(s);
    let suffix_len = len_s(suffix);
    if (suffix_len > s_len) {
        return false;
    }
    return find_from_s(s, suffix, s_len - suffix_len) == s_len - suffix_len;
}

/* -------------------------------------
   Character classification
   ------------------------------------ */

func is_space(c: byte) -> bool {
    return c == ' ' || c == '\n' || c == '\t' || c == '\r';
}

func is_digit(c: byte) -> bool {
    return c >= '0' && c <= '9';
}

func is_alpha(c: byte) -> bool {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

func is_alnum(c: byte) -> bool {
    return is_alpha(c) || is_digit(c);
}

/* -------------------------------------
   Character manipulation
   ------------------------------------ */

func to_digit(c: byte) -> int {
    return c - '0';
}

func to_upper(c: byte) -> byte {
    if (c >= 'a' && c <= 'z') {
        return (c - ('a' - 'A')) as byte;
    }
    return c;
}

func to_lower(c: byte) -> byte {
    if (c >= 'A' && c <= 'Z') {
        return (c + ('a' - 'A')) as byte;
    }
    return c;
}

/* -------------------------------------
   String manipulation and conversion
   ------------------------------------ */

/*
 * trim_s removes leading and trailing whitespace from the input string.
 */
func trim_s(s: string) -> string {
    let start: int = 0;
    let end: int = len_s(s) - 1;
    while (start <= end && is_space(char_at_s(s, start))) {
        start = start + 1;
    }
    while (end >= start && is_space(char_at_s(s, end))) {
        end = end - 1;
    }
    if (start > end) {
        return "";
    }
    return slice_s(s, start, end + 1);
}

/*
 * string_to_int converts a numeric string to an integer.
 * Handles optional leading '-' for negative numbers and ignores leading zeros.
 * Checks for overflow and invalid characters.
 * Returns null if the string is not a valid 32-bit signed integer.
 */
func string_to_int(s: string) -> int? {
    let sign = 1; // 1 for positive, -1 for negative
    let start_index: int = 0;
    if (len_s(s) == 0) {
        return null;
    }
    if (char_at_s(s, 0) == '-') {
        if (len_s(s) == 1) {
            return null; // Just a '-' is not valid
        }
        sign = -1;
        start_index = 1;
    }
    // Ignore leading zeros
    while (start_index < len_s(s) && char_at_s(s, start_index) == '0') {
        start_index = start_index + 1;
    }
    if (start_index == len_s(s)) {
        return 0; // The string is "0" or all zeros
    }
    // Check length to prevent overflow
    if (len_s(s) - start_index > 10) { // More than 10 digits is automatic overflow
        return null; // Overflow
    }
    let result: int = 0;
    // read first digit
    let first_char = char_at_s(s, start_index);
    if (!is_digit(first_char)) {
        return null; // Invalid character
    }
    result = sign * to_digit(first_char);
    start_index = start_index + 1;
    for (let i: int = start_index; i < len_s(s); i = i + 1) {
        let c = char_at_s(s, i);
        if (!is_digit(c)) {
            return null; // Invalid character
        }
        let digit = to_digit(c);
        // Check for overflow before multiplying and adding
        if (sign < 0) {
            if (result < (-2147483648 + digit) / 10) {
                return null; // Underflow
            }
        } else {
            if (result > (2147483647 - digit) / 10) {
                return null; // Overflow
            }
        }
        result = result * 10 + sign * digit;
    }
    return result;
}

func digit_to_char(d: int) -> byte {
    if (d < 10) {
        return ('0' + d) as byte;
    }
    return ('a' + d - 10) as byte;
}
