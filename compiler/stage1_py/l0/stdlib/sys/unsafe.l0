/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025-2026 gwz
 */

module sys.unsafe;

// //////////////////////////////////////////////////////////////////
//
// Runtime support functions for unsafe memory operations
//
// UNSAFE: Functions in this module are unsafe and may lead to
// undefined behavior if used incorrectly.
// Use with caution and ensure proper memory management.
//
// Note: These functions operate on raw pointers and do not perform
// any bounds checking.
// It is the caller's responsibility to ensure that pointers are
// valid and that memory is managed correctly.
// Misuse of these functions can lead to memory corruption, leaks,
// or crashes.
// Always validate inputs and handle memory carefully when using
// these functions.
//
// //////////////////////////////////////////////////////////////////

// Allocate a new block of memory of the given size
extern func rt_alloc(bytes: int) -> void*?;

// Resize an existing memory block to a new size
extern func rt_realloc(ptr: void*, new_bytes: int) -> void*?;

// Free a previously allocated memory block
extern func rt_free(ptr: void*) -> void;

// Allocate zero-initialized memory for multiple elements
extern func rt_calloc(count: int, elem_size: int) -> void*?;

// Copy bytes from one memory location to another
extern func rt_memcpy(dest: void*, src: void*, bytes: int) -> void*;

// Set a block of memory to a specific byte value
extern func rt_memset(dest: void*, value: int, bytes: int) -> void*;

// Compare two blocks of memory
extern func rt_memcmp(a: void*, b: void*, bytes: int) -> int;

// Get a pointer to an element in an array given its index
extern func rt_array_element(array_data: void*, element_size: int, index: int) -> void*;