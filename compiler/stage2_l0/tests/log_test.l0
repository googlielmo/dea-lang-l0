/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2026 gwz
 */

module log_test;

import std.io;
import std.assert;
import std.string;
import util.log;

func test_level_from_verbosity_zero() {
    let level = log_level_from_verbosity(0);
    assert(ord(level) == ord(LL_ERROR), "verbosity 0 should map to LL_ERROR");
}

func test_level_from_verbosity_one() {
    let level = log_level_from_verbosity(1);
    assert(ord(level) == ord(LL_INFO), "verbosity 1 should map to LL_INFO");
}

func test_level_from_verbosity_two() {
    let level = log_level_from_verbosity(2);
    assert(ord(level) == ord(LL_INFO), "verbosity 2 should map to LL_INFO");
}

func test_level_from_verbosity_three() {
    let level = log_level_from_verbosity(3);
    assert(ord(level) == ord(LL_DEBUG), "verbosity 3 should map to LL_DEBUG");
}

func test_level_names() {
    assert(eq_s(log_level_name(LL_SILENT), "SILENT"), "LL_SILENT name");
    assert(eq_s(log_level_name(LL_ERROR), "ERROR"), "LL_ERROR name");
    assert(eq_s(log_level_name(LL_WARNING), "WARNING"), "LL_WARNING name");
    assert(eq_s(log_level_name(LL_INFO), "INFO"), "LL_INFO name");
    assert(eq_s(log_level_name(LL_DEBUG), "DEBUG"), "LL_DEBUG name");
}

func test_format_stage_with_module() {
    let msg = log_format_stage("Loading", "hello");
    assert(eq_s(msg, "Loading module 'hello'"), "stage format with module");
}

func test_format_stage_without_module() {
    let msg = log_format_stage("Resolving names", "");
    assert(eq_s(msg, "Resolving names..."), "stage format without module");
}

func test_log_msg_respects_level() {
    // LL_ERROR config should not emit INFO messages (visual: no output expected)
    with (let cfg = log_config_create(LL_ERROR, false) => log_config_free(cfg)) {
        log_info(cfg, "this should be suppressed");
        log_debug(cfg, "this should also be suppressed");
        // If we reach here without crash, gating works
    }
}

func test_log_msg_emits_at_level() {
    // LL_DEBUG config should emit everything (visual: output on stderr)
    with (let cfg = log_config_create(LL_DEBUG, false) => log_config_free(cfg)) {
        log_error(cfg, "test error output");
        log_info(cfg, "test info output");
        log_debug(cfg, "test debug output");
    }
}

func test_log_rich_format() {
    // Rich format prepends [LEVEL] prefix (visual: check stderr)
    with (let cfg = log_config_create(LL_INFO, true) => log_config_free(cfg)) {
        log_info(cfg, "rich info message");
    }
}

func main() {
    test_level_from_verbosity_zero();
    test_level_from_verbosity_one();
    test_level_from_verbosity_two();
    test_level_from_verbosity_three();
    test_level_names();
    test_format_stage_with_module();
    test_format_stage_without_module();
    test_log_msg_respects_level();
    test_log_msg_emits_at_level();
    test_log_rich_format();
    printl_s("log_test: all tests passed");
}
