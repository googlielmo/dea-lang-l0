/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025-2026 gwz
 */

module tokens;

import std.io;
import std.string;
import std.unit;
import sys.rt;

import util.text;
import util.vector;
import util.linear_map;

enum TokenType {
    TT_EOF;

    TT_IDENT(text: string);                 // identifier, e.g. i, name, etc.
    TT_UNDERSCORE;                          // "_"
    TT_INT(text: string, value: int);       // integer literal, e.g. 42, -7, etc.
    TT_BYTE(text: string, value: byte);     // octet/byte literal, e.g. 'a', '\n', etc.
    TT_STRING(text: string, value: string); // string literal, e.g. "hello world", etc.

    // Keywords
    TT_MODULE;
    TT_IMPORT;
    TT_FUNC;
    TT_STRUCT;
    TT_ENUM;
    TT_TYPE;
    TT_EXTERN;
    TT_LET;
    TT_RETURN;
    TT_MATCH;
    TT_CASE;
    TT_IF;
    TT_ELSE;
    TT_WHILE;
    TT_FOR;
    TT_BREAK;
    TT_CONTINUE;
    TT_TRUE;
    TT_FALSE;
    TT_NULL;
    TT_AS;

    TT_NEW;
    TT_DROP;
    TT_WITH;
    TT_CLEANUP;

    // Punctuation / operators
    TT_LBRACE;          // {
    TT_RBRACE;          // }
    TT_LPAREN;          // (
    TT_RPAREN;          // )
    TT_LBRACKET;        // [
    TT_RBRACKET;        // ]
    TT_COMMA;           // ,
    TT_SEMI;            // ;
    TT_COLON;           // :
    TT_DOUBLE_COLON;    // ::
    TT_ARROW_FUNC;      // ->
    TT_ARROW_MATCH;     // =>
    TT_EQ;              // =
    TT_PLUS;            // +
    TT_MINUS;           // -
    TT_STAR;            // *
    TT_SLASH;           // /
    TT_MODULO;          // %
    TT_LT;              // <
    TT_GT;              // >
    TT_LE;              // <
    TT_GE;              // <=
    TT_EQEQ;            // ==
    TT_NE;              // !=
    TT_ANDAND;          // &&
    TT_OROR;            // ||
    TT_BANG;            // !
    TT_QUESTION;        // ?
    TT_DOT;             // .

    // Reserved operators
    TT_AMP;             // &
    TT_PIPE;            // |
    TT_CARET;           // ^
    TT_TILDE;           // ~
    TT_LSHIFT;          // <<
    TT_RSHIFT;          // >>

    TT_FUTURE_EXTENSION;  // placeholder for future tokens
}

struct Token {
    token_type: TokenType;
    index: int;     // offset in source, 0-based
    line: int;      // 1-based
    column: int;    // 1-based
}

func token_to_string(token: Token) -> string {
    match (token.token_type) {
        TT_EOF => { return "end-of-file"; }
        TT_IDENT(t) => { return concat3_s("ident(", t, ")"); }
        TT_UNDERSCORE => { return "_"; }
        TT_INT(t, v) => { return concat3_s("int(", t, ")"); }
        TT_BYTE(t, v) => { return concat3_s("byte(", t, ")"); }
        TT_STRING(t, v) => { return concat3_s("string(", t, ")"); }

        // Keywords
        TT_MODULE => { return "module"; }
        TT_IMPORT => { return "import"; }
        TT_FUNC => { return "func"; }
        TT_STRUCT => { return "struct"; }
        TT_ENUM => { return "enum"; }
        TT_TYPE => { return "type"; }
        TT_EXTERN => { return "extern"; }
        TT_LET => { return "let"; }
        TT_RETURN => { return "return"; }
        TT_MATCH => { return "match"; }
        TT_CASE => { return "case"; }
        TT_IF => { return "if"; }
        TT_ELSE => { return "else"; }
        TT_WHILE => { return "while"; }
        TT_FOR => { return "for"; }
        TT_BREAK => { return "break"; }
        TT_CONTINUE => { return "continue"; }
        TT_TRUE => { return "true"; }
        TT_FALSE => { return "false"; }
        TT_NULL => { return "null"; }
        TT_AS => { return "as"; }
        TT_NEW => { return "new"; }
        TT_DROP => { return "drop"; }
        TT_WITH => { return "with"; }
        TT_CLEANUP => { return "cleanup"; }

        // Punctuation / operators
        TT_LBRACE => { return "{"; }
        TT_RBRACE => { return "}"; }
        TT_LPAREN => { return "("; }
        TT_RPAREN => { return ")"; }
        TT_LBRACKET => { return "["; }
        TT_RBRACKET => { return "]"; }
        TT_COMMA => { return ","; }
        TT_SEMI => { return ";"; }
        TT_COLON => { return ":"; }
        TT_DOUBLE_COLON => { return "::"; }
        TT_ARROW_FUNC => { return "->"; }
        TT_ARROW_MATCH => { return "=>"; }
        TT_EQ => { return "="; }
        TT_PLUS => { return "+"; }
        TT_MINUS => { return "-"; }
        TT_STAR => { return "*"; }
        TT_SLASH => { return "/"; }
        TT_MODULO => { return "%"; }
        TT_LT => { return "<"; }
        TT_GT => { return ">"; }
        TT_LE => { return "<="; }
        TT_GE => { return ">="; }
        TT_EQEQ => { return "=="; }
        TT_NE => { return "!="; }
        TT_ANDAND => { return "&&"; }
        TT_OROR => { return "||"; }
        TT_BANG => { return "!"; }
        TT_QUESTION => { return "?"; }
        TT_DOT => { return "."; }

        TT_AMP => { return "&"; }
        TT_PIPE => { return "|"; }
        TT_CARET => { return "^"; }
        TT_TILDE => { return "~"; }
        TT_LSHIFT => { return "<<"; }
        TT_RSHIFT => { return ">>"; }

        TT_FUTURE_EXTENSION => { return "<future-extension>"; }
    }
}

func is_reserved_ident_word(word: string) -> bool {
    return eq_s(word, "void") || eq_s(word, "bool") || eq_s(word, "string") ||
           eq_s(word, "int") || eq_s(word, "byte");
}

func is_reserved_keyword(token: Token) -> bool {
    match (token.token_type) {
        TT_MODULE => { return true; }
        TT_IMPORT => { return true; }
        TT_FUNC => { return true; }
        TT_STRUCT => { return true; }
        TT_ENUM => { return true; }
        TT_TYPE => { return true; }
        TT_EXTERN => { return true; }
        TT_LET => { return true; }
        TT_RETURN => { return true; }
        TT_MATCH => { return true; }
        TT_CASE => { return true; }
        TT_IF => { return true; }
        TT_ELSE => { return true; }
        TT_WHILE => { return true; }
        TT_FOR => { return true; }
        TT_BREAK => { return true; }
        TT_CONTINUE => { return true; }
        TT_TRUE => { return true; }
        TT_FALSE => { return true; }
        TT_NULL => { return true; }
        TT_AS => { return true; }
        TT_NEW => { return true; }
        TT_DROP => { return true; }
        TT_WITH => { return true; }
        TT_CLEANUP => { return true; }
        TT_IDENT(t) => { return is_reserved_ident_word(t); }
        TT_FUTURE_EXTENSION => { return true; }
        _ => { return false; }
    }
}

func ident_to_token(ident: string, index: int, line: int, col: int) -> Token {
    case (ident) {
         "module" => return Token(TT_MODULE, index, line, col);
         "import" => return Token(TT_IMPORT, index, line, col);
         "func" => return Token(TT_FUNC, index, line, col);
         "struct" => return Token(TT_STRUCT, index, line, col);
         "enum" => return Token(TT_ENUM, index, line, col);
         "type" => return Token(TT_TYPE, index, line, col);
         "extern" => return Token(TT_EXTERN, index, line, col);
         "let" => return Token(TT_LET, index, line, col);
         "return" => return Token(TT_RETURN, index, line, col);
         "match" => return Token(TT_MATCH, index, line, col);
         "case" => return Token(TT_CASE, index, line, col);
         "if" => return Token(TT_IF, index, line, col);
         "else" => return Token(TT_ELSE, index, line, col);
         "while" => return Token(TT_WHILE, index, line, col);
         "for" => return Token(TT_FOR, index, line, col);
         "break" => return Token(TT_BREAK, index, line, col);
         "continue" => return Token(TT_CONTINUE, index, line, col);
         "true" => return Token(TT_TRUE, index, line, col);
         "false" => return Token(TT_FALSE, index, line, col);
         "null" => return Token(TT_NULL, index, line, col);
         "as" => return Token(TT_AS, index, line, col);
         "new" => return Token(TT_NEW, index, line, col);
         "drop" => return Token(TT_DROP, index, line, col);
         "with" => return Token(TT_WITH, index, line, col);
         "cleanup" => return Token(TT_CLEANUP, index, line, col);
         "_" => return Token(TT_UNDERSCORE, index, line, col);
    }
    if (eq_s(ident, "tiny") || eq_s(ident, "short") || eq_s(ident, "long") ||
        eq_s(ident, "ushort") || eq_s(ident, "uint") || eq_s(ident, "ulong") ||
        eq_s(ident, "float") || eq_s(ident, "double") || eq_s(ident, "in") ||
        eq_s(ident, "const") ) {
        return Token(TT_FUTURE_EXTENSION, index, line, col);
    }
    return Token(TT_IDENT(ident), index, line, col);
}

func is_expr_ending_token_type(token_type: TokenType) -> bool {
    match (token_type) {
        TT_IDENT(t) => { return true; }
        TT_INT(t, v) => { return true; }
        TT_BYTE(t, v) => { return true; }
        TT_STRING(t, v) => { return true; }
        TT_TRUE => { return true; }
        TT_FALSE => { return true; }
        TT_NULL => { return true; }
        TT_RPAREN => { return true; }
        TT_RBRACKET => { return true; }
        _ => { return false; }
    }
}

// ------------------------------------
// Token Vector utilities
// ------------------------------------

struct TokenVector {
    vec: VectorBase*;
}

func tv_create() -> TokenVector {
    let vec = vec_create(sizeof(Token), 16);
    return TokenVector(vec);
}

func tv_push(self: TokenVector, token: Token) {
    vec_grow(self.vec);
    let data = vec_get(self.vec, self.vec.length - 1) as Token*;
    *data = token;
}

func tv_get(self: TokenVector, index: int) -> Token {
    vec_check(self.vec, index);
    let data = vec_get(self.vec, index) as Token*;
    return *data;
}

func tv_len(self: TokenVector) -> int {
    return self.vec.length;
}

func tv_free(self: TokenVector) {
    for (let i: int = 0; i < self.vec.length; i = i + 1) {
        let tok_ptr = vec_get(self.vec, i) as Token*;
        match (tok_ptr.token_type) {
            TT_IDENT(t) => { rt_string_release(t); }
            TT_INT(t, v) => { rt_string_release(t); }
            TT_BYTE(t, v) => { rt_string_release(t); }
            TT_STRING(t, v) => { rt_string_release(t); rt_string_release(v); }
            _ => {}
        }
    }
    vec_free(self.vec);
}
