/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025-2026 gwz
 */

module util.text;

import std.string;
import std.math;
import std.assert;

import util.vector;

/* -------------------------------------
   Character classification functions
   ------------------------------------ */

func is_space(c: byte) -> bool {
    return c == ' ' || c == '\n' || c == '\t' || c == '\r';
}

func is_digit(c: byte) -> bool {
    return c >= '0' && c <= '9';
}

func is_alpha(c: byte) -> bool {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

func is_alnum(c: byte) -> bool {
    return is_alpha(c) || is_digit(c);
}

/* -------------------------------------
   Character manipulation functions
   ------------------------------------ */

func to_digit(c: byte) -> int {
    return c - '0';
}

func to_upper(c: byte) -> byte {
    if (c >= 'a' && c <= 'z') {
        return (c - ('a' - 'A')) as byte;
    }
    return c;
}

func to_lower(c: byte) -> byte {
    if (c >= 'A' && c <= 'Z') {
        return (c + ('a' - 'A')) as byte;
    }
    return c;
}

/* -------------------------------------
   StringBuffer for efficient string building
   ------------------------------------ */

struct StringBuffer {
    parts: VectorString*; // Vector of strings
}

func sb_create() -> StringBuffer* {
    let parts = vs_create(8);
    let self = new StringBuffer(parts);
    return self;
}

func sb_append(self: StringBuffer*, s: string) {
    vs_push(self.parts, s);
}

func sb_to_string(self: StringBuffer*) -> string {
    let result: string = "";
    for (let i: int = 0; i < vs_size(self.parts); i = i + 1) {
        let part = vs_get(self.parts, i);
        result = concat_s(result, part);
    }
    return result;
}

func sb_size(self: StringBuffer*) -> int {
    let size: int = 0;
    for (let i: int = 0; i < vs_size(self.parts); i = i + 1) {
        let part = vs_get(self.parts, i);
        size = size + len_s(part);
    }
    return size;
}

func sb_free(self: StringBuffer*) {
    vs_free(self.parts);
    drop self;
}

/* ------------------------------------
   CharBuffer for efficient string building
   ------------------------------------ */

struct CharBuffer {
    chars: VectorBase*; // Vector of byte
}

func cb_create() -> CharBuffer* {
    let chars = vec_create(sizeof(byte), 16);
    let self = new CharBuffer(chars);
    return self;
}

func cb_append(self: CharBuffer*, c: byte) {
    let dest = vec_push(self.chars) as byte*;
    *dest = c;
}

func cb_append_s(self: CharBuffer*, s: string) {
    for (let i: int = 0; i < len_s(s); i = i + 1) {
        let c = char_at_s(s, i);
        cb_append(self, c);
    }
}

func cb_size(self: CharBuffer*) -> int {
    return vec_size(self.chars);
}

func cb_reverse(cb: CharBuffer*) {
    let size = cb_size(cb);
    for (let i: int = 0; i < size / 2; i = i + 1) {
        let a = vec_get(cb.chars, i) as byte*;
        let b = vec_get(cb.chars, size - 1 - i) as byte*;
        let temp = *a;
        *a = *b;
        *b = temp;
    }
}

func cb_to_string(self: CharBuffer*) -> string {
    let size = cb_size(self);
    let bytes = vec_get(self.chars, 0) as byte*;
    return bytes_to_s(bytes, size);
}

func cb_clear(self: CharBuffer*) {
    vec_clear(self.chars);
}

func cb_free(self: CharBuffer*) {
    vec_free(self.chars);
    drop self;
}

/* ------------------------------------
   Additional string utility functions
   ------------------------------------ */

/*
 * concat3_s concatenates three strings and returns the result.
 */
func concat3_s(a: string, b: string, c: string) -> string {
    return concat_s(concat_s(a, b), c);
}

/*
 * repeat_s returns a new string that is the input string `s` repeated `count` times.
 */
func repeat_s(s: string, count: int) -> string {
    let result: string = "";
    for (let i: int = 0; i < count; i = i + 1) {
        result = concat_s(result, s);
    }
    return result;
}

/*
 * trim_s removes leading and trailing whitespace from the input string.
 */
func trim_s(s: string) -> string {
    let start: int = 0;
    let end: int = len_s(s) - 1;
    while (start <= end && is_space(char_at_s(s, start))) {
        start = start + 1;
    }
    while (end >= start && is_space(char_at_s(s, end))) {
        end = end - 1;
    }
    if (start > end) {
        return "";
    }
    return slice_s(s, start, end + 1);
}

/*
 * to_upper_s converts all characters in the input string to uppercase.
 */
func to_upper_s(s: string) -> string {
    let result: StringBuffer* = sb_create();
    for (let i: int = 0; i < len_s(s); i = i + 1) {
        let c = char_at_s(s, i);
        sb_append(result, byte_to_s(to_upper(c)));
    }
    let upper_str = sb_to_string(result);
    sb_free(result);
    return upper_str;
}

/*
 * to_lower_s converts all characters in the input string to lowercase.
 */
func to_lower_s(s: string) -> string {
    let result: StringBuffer* = sb_create();
    for (let i: int = 0; i < len_s(s); i = i + 1) {
        let c = char_at_s(s, i);
        sb_append(result, byte_to_s(to_lower(c)));
    }
    let lower_str = sb_to_string(result);
    sb_free(result);
    return lower_str;
}

/*
 * string_to_int converts a numeric string to an integer.
 * Handles optional leading '-' for negative numbers and ignores leading zeros.
 * Checks for overflow and invalid characters.
 * Returns null if the string is not a valid 32-bit signed integer.
 */
func string_to_int(s: string) -> int? {
    let sign = 1; // 1 for positive, -1 for negative
    let start_index: int = 0;
    if (len_s(s) == 0) {
        return null;
    }
    if (char_at_s(s, 0) == '-') {
        if (len_s(s) == 1) {
            return null; // Just a '-' is not valid
        }
        sign = -1;
        start_index = 1;
    }
    // Ignore leading zeros
    while (start_index < len_s(s) && char_at_s(s, start_index) == '0') {
        start_index = start_index + 1;
    }
    if (start_index == len_s(s)) {
        return 0; // The string is "0" or all zeros
    }
    // Check length to prevent overflow
    if (len_s(s) - start_index > 10) { // More than 10 digits is automatic overflow
        return null; // Overflow
    }
    let result: int = 0;
    // read first digit
    let first_char = char_at_s(s, start_index);
    if (!is_digit(first_char)) {
        return null; // Invalid character
    }
    result = sign * to_digit(first_char);
    start_index = start_index + 1;
    for (let i: int = start_index; i < len_s(s); i = i + 1) {
        let c = char_at_s(s, i);
        if (!is_digit(c)) {
            return null; // Invalid character
        }
        let digit = to_digit(c);
        // Check for overflow before multiplying and adding
        if (sign < 0) {
            if (result < (-2147483648 + digit) / 10) {
                return null; // Underflow
            }
        } else {
            if (result > (2147483647 - digit) / 10) {
                return null; // Overflow
            }
        }
        result = result * 10 + sign * digit;
    }
    return result;
}

func int_to_string_base(value: int, base: int) -> string {
    assert(base >= 2 && base <= 16, "Base must be between 2 and 16");
    if (value == 0) {
        return "0";
    }
    let sign = 1;
    if (value < 0) {
        sign = -1;
    }

    let cb = cb_create();

    let digit = emod(value, base);
    if (sign < 0 && digit != 0) {
        digit = base - digit;
    }
    cb_append(cb, digit_to_char(digit));
    value = value / (sign * base); // divide with sign adjustment

    while (value != 0) {
        digit = emod(value, base);
        cb_append(cb, digit_to_char(digit));
        value = value / base;
    }
    if (sign < 0) {
        cb_append(cb, '-' as byte);
    }

    cb_reverse(cb);
    let result = cb_to_string(cb);
    cb_free(cb);
    return result;
}

func digit_to_char(d: int) -> byte {
    if (d < 10) {
        return ('0' + d) as byte;
    }
    return ('a' + d - 10) as byte;
}

func int_to_string(value: int) -> string {
    return int_to_string_base(value, 10);
}

func int_to_hex_string(value: int) -> string {
    return int_to_string_base(value, 16);
}

func int_to_bin_string(value: int) -> string {
    return int_to_string_base(value, 2);
}
