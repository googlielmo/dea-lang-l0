/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025-2026 gwz
 */

module util.string;

import std.string;

import util.vector;

/* -------------------------------------
   Character classification functions
   ------------------------------------ */

type char = byte;

func is_space(c: char) -> bool {
    return c == ' ' || c == '\n' || c == '\t' || c == '\r';
}

func is_digit(c: char) -> bool {
    return c >= '0' && c <= '9';
}

func is_alpha(c: char) -> bool {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

func is_alnum(c: char) -> bool {
    return is_alpha(c) || is_digit(c);
}

/* -------------------------------------
   Character manipulation functions
   ------------------------------------ */

func to_digit(c: char) -> int {
    return c - '0';
}

func to_upper(c: char) -> char {
    if (c >= 'a' && c <= 'z') {
        return (c - ('a' - 'A')) as char;
    }
    return c;
}

func to_lower(c: char) -> char {
    if (c >= 'A' && c <= 'Z') {
        return (c + ('a' - 'A')) as char;
    }
    return c;
}

/* -------------------------------------
   StringBuffer for efficient string building
   ------------------------------------ */

struct StringBuffer {
    parts: VectorString*; // Vector of strings
}

func sb_create() -> StringBuffer* {
    let parts = vs_create(8);
    let self = new StringBuffer(parts);
    return self;
}

func sb_append(self: StringBuffer*, s: string) {
    vs_push(self.parts, s);
}

func sb_to_string(self: StringBuffer*) -> string {
    let result: string = "";
    for (let i: int = 0; i < vs_size(self.parts); i = i + 1) {
        let part = vs_get(self.parts, i);
        result = concat_s(result, part);
    }
    return result;
}

func sb_size(self: StringBuffer*) -> int {
    let size: int = 0;
    for (let i: int = 0; i < vs_size(self.parts); i = i + 1) {
        let part = vs_get(self.parts, i);
        size = size + len_s(part);
    }
    return size;
}

func sb_free(self: StringBuffer*) {
    vs_free(self.parts);
    drop self;
}

/* ------------------------------------
   CharBuffer for efficient string building
   ------------------------------------ */

struct CharBuffer {
    chars: VectorBase*; // Vector of char (byte)
}

func cb_create() -> CharBuffer* {
    let chars = vec_create(sizeof(byte), 16);
    let self = new CharBuffer(chars);
    return self;
}

func cb_append(self: CharBuffer*, c: char) {
    let dest = vec_push(self.chars) as byte*;
    *dest = c;
}

func cb_size(self: CharBuffer*) -> int {
    return vec_size(self.chars);
}

func cb_to_string(self: CharBuffer*) -> string {
    let size = cb_size(self);
    let bytes = vec_get(self.chars, 0) as byte*;
    return bytes_to_s(bytes, size);
}

func cb_clear(self: CharBuffer*) {
    vec_clear(self.chars);
}

func cb_free(self: CharBuffer*) {
    vec_free(self.chars);
    drop self;
}

/* ------------------------------------
   Additional string utility functions
   ------------------------------------ */

/*
 * concat3_s concatenates three strings and returns the result.
 */
func concat3_s(a: string, b: string, c: string) -> string {
    return concat_s(concat_s(a, b), c);
}

/*
 * repeat_s returns a new string that is the input string `s` repeated `count` times.
 */
func repeat_s(s: string, count: int) -> string {
    let result: string = "";
    for (let i: int = 0; i < count; i = i + 1) {
        result = concat_s(result, s);
    }
    return result;
}

/*
 * trim_s removes leading and trailing whitespace from the input string.
 */
func trim_s(s: string) -> string {
    let start: int = 0;
    let end: int = len_s(s) - 1;
    while (start <= end && is_space(char_at_s(s, start))) {
        start = start + 1;
    }
    while (end >= start && is_space(char_at_s(s, end))) {
        end = end - 1;
    }
    if (start > end) {
        return "";
    }
    return slice_s(s, start, end + 1);
}

/*
 * to_upper_s converts all characters in the input string to uppercase.
 */
func to_upper_s(s: string) -> string {
    let result: StringBuffer* = sb_create();
    for (let i: int = 0; i < len_s(s); i = i + 1) {
        let c = char_at_s(s, i);
        sb_append(result, byte_to_s(to_upper(c)));
    }
    let upper_str = sb_to_string(result);
    sb_free(result);
    return upper_str;
}
