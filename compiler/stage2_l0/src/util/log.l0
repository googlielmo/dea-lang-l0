/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2026 gwz
 */

module util.log;

import std.io;
import std.string;
import std.text;

enum LogLevel {
    LL_SILENT;
    LL_ERROR;
    LL_WARNING;
    LL_INFO;
    LL_DEBUG;
}

struct LogConfig {
    level: LogLevel;
    rich: bool;
}

func log_config_create(level: LogLevel, rich: bool) -> LogConfig* {
    return new LogConfig(level, rich);
}

func log_config_free(cfg: LogConfig*) {
    drop cfg;
}

func log_level_from_verbosity(verbosity: int) -> LogLevel {
    if (verbosity >= 3) { return LL_DEBUG; }
    if (verbosity >= 1) { return LL_INFO; }
    return LL_ERROR;
}

func log_level_name(level: LogLevel) -> string {
    match (level) {
        LL_SILENT => { return "SILENT"; }
        LL_ERROR => { return "ERROR"; }
        LL_WARNING => { return "WARNING"; }
        LL_INFO => { return "INFO"; }
        LL_DEBUG => { return "DEBUG"; }
    }
}

func log_msg(cfg: LogConfig*, level: LogLevel, message: string) {
    if (ord(cfg.level) < ord(level)) {
        return;
    }

    if (cfg.rich) {
        err_printl_s(concat4_s("[", log_level_name(level), "] ", message));
    } else {
        err_printl_s(message);
    }
}

func log_error(cfg: LogConfig*, message: string) {
    log_msg(cfg, LL_ERROR, message);
}

func log_warning(cfg: LogConfig*, message: string) {
    log_msg(cfg, LL_WARNING, message);
}

func log_info(cfg: LogConfig*, message: string) {
    log_msg(cfg, LL_INFO, message);
}

func log_debug(cfg: LogConfig*, message: string) {
    log_msg(cfg, LL_DEBUG, message);
}

func log_format_stage(stage: string, module_name: string) -> string {
    if (len_s(module_name) > 0) {
        return concat4_s(stage, " module '", module_name, "'");
    }
    return concat_s(stage, "...");
}

func log_stage(cfg: LogConfig*, stage: string, module_name: string) {
    log_info(cfg, log_format_stage(stage, module_name));
}
