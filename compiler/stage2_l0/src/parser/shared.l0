/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2026 gwz
 */

module parser.shared;

import std.string;
import std.unit;

import util.text;
import util.vector;

import tokens;
import ast;

struct ImplParseError {
    code: string;
    message: string;
    line: int;
    column: int;
    filename: string;
}

enum ImplParseErrorState {
    ImplParseNoError;
    ImplParseHasError(err: ImplParseError);
}

struct ImplParseResult {
    root_module: Module*?;
    expr_arena: ExprArena*;
    stmt_arena: StmtArena*;
    pattern_arena: PatternArena*;
    error: ImplParseErrorState;
}

/* ------------------------------------
   Parser state
   ------------------------------------ */

struct ParserState {
    tokens: TokenVector;
    index: int;
    filename: string;
    error: ImplParseErrorState;

    expr_arena: ExprArena*;
    stmt_arena: StmtArena*;
    pattern_arena: PatternArena*;
}

func ps_create(tokens: TokenVector, filename: string) -> ParserState* {
    return new ParserState(
        tokens,
        0,
        filename,
        ImplParseNoError,
        expr_arena_create(128),
        stmt_arena_create(128),
        pattern_arena_create(64)
    );
}

func ps_destroy(self: ParserState*) {
    drop self;
}

func ps_set_error(self: ParserState*, code: string, message: string, tok: Token) {
    if (ord(self.error) == ord(ImplParseNoError)) {
        self.error = ImplParseHasError(ImplParseError(code, message, tok.line, tok.column, self.filename));
    }
}

func ps_has_error(self: ParserState*) -> bool {
    return ord(self.error) != ord(ImplParseNoError);
}

/* ------------------------------------
   Token utilities
   ------------------------------------ */

func tok_is(tok: Token, kind_ord: int) -> bool {
    return ord(tok.token_type) == kind_ord;
}

func tok_is_ident(tok: Token) -> bool {
    match (tok.token_type) {
        TT_IDENT(t) => { return true; }
        _ => { return false; }
    }
}

func tok_is_int(tok: Token) -> bool {
    match (tok.token_type) {
        TT_INT(t, v) => { return true; }
        _ => { return false; }
    }
}

func tok_is_byte(tok: Token) -> bool {
    match (tok.token_type) {
        TT_BYTE(t, v) => { return true; }
        _ => { return false; }
    }
}

func tok_is_string(tok: Token) -> bool {
    match (tok.token_type) {
        TT_STRING(t, v) => { return true; }
        _ => { return false; }
    }
}

func tok_is_future_extension(tok: Token) -> bool {
    return ord(tok.token_type) == ord(TT_FUTURE_EXTENSION);
}

func ps_peek(self: ParserState*) -> Token {
    return tv_get(self.tokens, self.index);
}

func ps_last(self: ParserState*) -> Token {
    if (self.index > 0) {
        return tv_get(self.tokens, self.index - 1);
    }
    return tv_get(self.tokens, 0);
}

func ps_at_end(self: ParserState*) -> bool {
    return tok_is(ps_peek(self), ord(TT_EOF));
}

func ps_advance(self: ParserState*) -> Token {
    let tok = ps_peek(self);
    if (!ps_at_end(self)) {
        self.index = self.index + 1;
    }
    return tok;
}

func ps_check(self: ParserState*, kind_ord: int) -> bool {
    return tok_is(ps_peek(self), kind_ord);
}

func ps_match(self: ParserState*, kind_ord: int) -> bool {
    if (ps_check(self, kind_ord)) {
        ps_advance(self);
        return true;
    }
    return false;
}

func ps_match_any2(self: ParserState*, k1: int, k2: int) -> bool {
    if (ps_match(self, k1)) {
        return true;
    }
    if (ps_match(self, k2)) {
        return true;
    }
    return false;
}

func ps_match_any3(self: ParserState*, k1: int, k2: int, k3: int) -> bool {
    if (ps_match(self, k1)) {
        return true;
    }
    if (ps_match(self, k2)) {
        return true;
    }
    if (ps_match(self, k3)) {
        return true;
    }
    return false;
}

func ps_match_any4(self: ParserState*, k1: int, k2: int, k3: int, k4: int) -> bool {
    if (ps_match(self, k1)) {
        return true;
    }
    if (ps_match(self, k2)) {
        return true;
    }
    if (ps_match(self, k3)) {
        return true;
    }
    if (ps_match(self, k4)) {
        return true;
    }
    return false;
}

func ps_check_ident(self: ParserState*) -> bool {
    return tok_is_ident(ps_peek(self));
}

func ps_match_ident(self: ParserState*) -> bool {
    if (ps_check_ident(self)) {
        ps_advance(self);
        return true;
    }
    return false;
}

func ps_check_int(self: ParserState*) -> bool {
    return tok_is_int(ps_peek(self));
}

func ps_match_int(self: ParserState*) -> bool {
    if (ps_check_int(self)) {
        ps_advance(self);
        return true;
    }
    return false;
}

func ps_check_byte(self: ParserState*) -> bool {
    return tok_is_byte(ps_peek(self));
}

func ps_match_byte(self: ParserState*) -> bool {
    if (ps_check_byte(self)) {
        ps_advance(self);
        return true;
    }
    return false;
}

func ps_check_string(self: ParserState*) -> bool {
    return tok_is_string(ps_peek(self));
}

func ps_match_string(self: ParserState*) -> bool {
    if (ps_check_string(self)) {
        ps_advance(self);
        return true;
    }
    return false;
}

func ps_expect(self: ParserState*, kind_ord: int, code: string, msg: string) -> Token? {
    if (!ps_check(self, kind_ord)) {
        let got = token_to_string(ps_peek(self));
        ps_set_error(self, code, concat3_s(msg, ", got ", concat_s(got, " instead")), ps_peek(self));
        return null;
    }
    return ps_advance(self);
}

func ps_expect_ident(self: ParserState*, code: string, msg: string) -> Token? {
    if (!ps_check_ident(self)) {
        let got = token_to_string(ps_peek(self));
        ps_set_error(self, code, concat3_s(msg, ", got ", concat_s(got, " instead")), ps_peek(self));
        return null;
    }
    return ps_advance(self);
}

func token_ident_text(tok: Token) -> string? {
    match (tok.token_type) {
        TT_IDENT(t) => { return t; }
        _ => { return null; }
    }
}

func token_int_text(tok: Token) -> string? {
    match (tok.token_type) {
        TT_INT(t, v) => { return t; }
        _ => { return null; }
    }
}

func token_int_value(tok: Token) -> int? {
    match (tok.token_type) {
        TT_INT(t, v) => { return v; }
        _ => { return null; }
    }
}

func token_byte_text(tok: Token) -> string? {
    match (tok.token_type) {
        TT_BYTE(t, v) => { return t; }
        _ => { return null; }
    }
}

func token_string_text(tok: Token) -> string? {
    match (tok.token_type) {
        TT_STRING(t, v) => { return t; }
        _ => { return null; }
    }
}

func token_text_for_width(tok: Token) -> string {
    match (tok.token_type) {
        TT_IDENT(t) => { return t; }
        TT_INT(t, v) => { return t; }
        TT_BYTE(t, v) => { return t; }
        TT_STRING(t, v) => { return t; }
        TT_EOF => { return ""; }
        _ => { return token_to_string(tok); }
    }
}

func token_width(tok: Token) -> int {
    return len_s(token_text_for_width(tok));
}

func ps_span_start(self: ParserState*) -> Span {
    let here = ps_peek(self);
    return Span(here.line, here.column, here.line, here.column);
}

func ps_extend_span(self: ParserState*, start: Span) -> Span {
    let here = ps_last(self);
    return Span(
        start.start_line,
        start.start_column,
        here.line,
        here.column + token_width(here)
    );
}

func ps_expect_variable_name(self: ParserState*, code: string, msg: string) -> Token? {
    let tok = ps_peek(self);
    if (tok_is_future_extension(tok)) {
        let t = token_to_string(tok);
        ps_set_error(self, "PAR-0010", concat3_s("invalid variable name '", t, "': reserved keyword"), tok);
        return null;
    }
    let got = ps_expect_ident(self, code, msg)?;
    if (is_reserved_keyword(got)) {
        let ident = token_ident_text(got) as string;
        ps_set_error(self, "PAR-0011", concat3_s("invalid variable name '", ident, "': reserved identifier"), got);
        return null;
    }
    return got;
}

/* ------------------------------------
   Name helpers
   ------------------------------------ */

func parse_dotted_name_rest(self: ParserState*, first: string) -> string? {
    let name = first;
    while (ps_match(self, ord(TT_DOT))) {
        let ident = ps_expect_ident(self, "PAR-0300", "[PAR-0300] expected identifier after '.' in module name")?;
        let ident_text = token_ident_text(ident) as string;
        name = concat3_s(name, ".", ident_text);
    }
    return name;
}

struct QualifiedNameResult {
    module_path: VectorString*;
    name_qualifier: VectorString*?;
    name_tok: Token;
}

func qn_result_free_only_container(self: QualifiedNameResult*) {
    drop self;
}

func qn_result_free_all(self: QualifiedNameResult*) {
    vs_free(self.module_path);
    vs_free_opt(self.name_qualifier);
    drop self;
}

func ps_try_parse_qualified_name(self: ParserState*) -> QualifiedNameResult*? {
    if (!ps_check_ident(self)) {
        return null;
    }

    // Lookahead without building strings: parse only if we truly have ModulePath::Name.
    let i = self.index;
    let n = tv_len(self.tokens);

    let look = i + 1; // after first identifier
    while (look < n && tok_is(tv_get(self.tokens, look), ord(TT_DOT))) {
        look = look + 1;
        if (look >= n || !tok_is_ident(tv_get(self.tokens, look))) {
            return null;
        }
        look = look + 1;
    }

    if (look >= n || !tok_is(tv_get(self.tokens, look), ord(TT_DOUBLE_COLON))) {
        return null;
    }

    // Commit parse and build vectors.
    let first = ps_expect_ident(self, "PAR-0401", "[PAR-0401] expected identifier before '::'")?;

    with (let parts: VectorString*? = vs_create(4) => vs_free_opt(parts),
          let qualifier: VectorString*? = null => vs_free_opt(qualifier)) {
        vs_push(parts as VectorString*, token_ident_text(first) as string);

        while (ps_match(self, ord(TT_DOT))) {
            let part = ps_expect_ident(self, "PAR-0300", "[PAR-0300] expected identifier after '.' in module name")?;
            vs_push(parts as VectorString*, token_ident_text(part) as string);
        }

        ps_expect(self, ord(TT_DOUBLE_COLON), "PAR-0401", "[PAR-0401] expected '::' in qualified name")?;
        let name_tok = ps_expect_ident(self, "PAR-0401", "[PAR-0401] expected identifier after '::'")?;

        let current_name_tok = name_tok;

        while (ps_match(self, ord(TT_DOUBLE_COLON))) {
            if (qualifier == null) {
                qualifier = vs_create(2);
            }
            vs_push(qualifier as VectorString*, token_ident_text(current_name_tok) as string);
            current_name_tok = ps_expect_ident(self, "PAR-0401", "[PAR-0401] expected identifier after '::'")?;
        }

        let result = new QualifiedNameResult(parts as VectorString*, qualifier, current_name_tok);
        parts = null;
        qualifier = null;
        return result;
    }
}

/* ------------------------------------
   Type parsing
   ------------------------------------ */

func ps_parse_type(self: ParserState*) -> TypeRef*? {
    let start = ps_span_start(self);

    let module_path: VectorString*? = null;
    let name_qualifier: VectorString*? = null;
    let name_tok = Token(TT_EOF, 0, 0, 0);

    let qualified = ps_try_parse_qualified_name(self);
    if (qualified != null) {
        let q = qualified as QualifiedNameResult*;
        module_path = q.module_path;
        name_qualifier = q.name_qualifier;
        name_tok = q.name_tok;
        qn_result_free_only_container(q);
    } else {
        name_tok = ps_expect_ident(self, "PAR-0400", "[PAR-0400] expected type name")?;
    }

    let pointer_depth = 0;
    while (ps_match(self, ord(TT_STAR))) {
        pointer_depth = pointer_depth + 1;
    }

    let is_nullable = false;
    if (ps_match(self, ord(TT_QUESTION))) {
        is_nullable = true;
    }

    if (ps_check(self, ord(TT_LBRACKET))) {
        ps_set_error(self, "PAR-9401", "[PAR-9401] array types not yet supported: use pointers and [] indexing in expressions", ps_peek(self));
        vs_free_opt(module_path);
        vs_free_opt(name_qualifier);
        return null;
    }

    let type_name = token_ident_text(name_tok) as string;
    return new TypeRef(type_name, pointer_depth, is_nullable, module_path, name_qualifier, ps_extend_span(self, start));
}
func ps_check_reserved_binary_op(self: ParserState*) -> Unit? {
    let tok = ps_peek(self);
    if (tok_is(tok, ord(TT_AMP))) {
        ps_set_error(self, "PAR-0226", "[PAR-0226] '&' (bitwise AND) operator is not yet supported", tok);
        return null;
    }
    if (tok_is(tok, ord(TT_PIPE))) {
        ps_set_error(self, "PAR-0226", "[PAR-0226] '|' (bitwise OR) operator is not yet supported", tok);
        return null;
    }
    if (tok_is(tok, ord(TT_CARET))) {
        ps_set_error(self, "PAR-0226", "[PAR-0226] '^' (bitwise XOR) operator is not yet supported", tok);
        return null;
    }
    if (tok_is(tok, ord(TT_LSHIFT))) {
        ps_set_error(self, "PAR-0226", "[PAR-0226] '<<' (left shift) operator is not yet supported", tok);
        return null;
    }
    if (tok_is(tok, ord(TT_RSHIFT))) {
        ps_set_error(self, "PAR-0226", "[PAR-0226] '>>' (right shift) operator is not yet supported", tok);
        return null;
    }
    return present();
}
