/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2026 gwz
 */

module parser.expr;

import std.string;

import std.text;
import std.vector;

import tokens;
import ast;
import parser.shared;

/* ------------------------------------
   Expression parsing
   ------------------------------------ */

func ps_is_builtin_type_name(self: ParserState*) -> bool {
    if (!ps_check_ident(self)) {
        return false;
    }
    let t = token_ident_text(ps_peek(self)) as string;
    return eq_s(t, "int") || eq_s(t, "byte") || eq_s(t, "bool") || eq_s(t, "string") || eq_s(t, "void");
}

func ps_is_unambiguous_type_start(self: ParserState*) -> bool {
    if (ps_is_builtin_type_name(self)) {
        return true;
    }

    if (!ps_check_ident(self)) {
        return false;
    }

    let saved = self.index;
    ps_advance(self); // identifier

    let has_suffix = false;
    while (ps_check(self, ord(TT_STAR)) || ps_check(self, ord(TT_QUESTION))) {
        has_suffix = true;
        ps_advance(self);
    }

    let at_boundary = ps_check(self, ord(TT_RPAREN)) || ps_check(self, ord(TT_COMMA));

    self.index = saved;
    return has_suffix && at_boundary;
}

func ps_parse_call_argument(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    if (ps_is_unambiguous_type_start(self)) {
        let type_ref = ps_parse_type(self)?;
        let node = expr_node_create(EX_TYPE, ps_extend_span(self, start));
        node.type_ref = type_ref;
        return expr_arena_add(self.expr_arena, node);
    }
    return ps_parse_expr(self);
}

func ps_parse_expr(self: ParserState*) -> ExprId? {
    return ps_parse_or_expr(self);
}

func ps_parse_or_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_and_expr(self)?;
    ps_check_reserved_binary_op(self)?;

    let current = expr;
    while (ps_match(self, ord(TT_OROR))) {
        let op_tok = ps_last(self);
        let right = ps_parse_and_expr(self)?;
        ps_check_reserved_binary_op(self)?;

        let node = expr_node_create(EX_BINARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = current;
        node.expr_b = right;
        current = expr_arena_add(self.expr_arena, node);
    }
    return current;
}

func ps_parse_and_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_equality_expr(self)?;
    ps_check_reserved_binary_op(self)?;

    let current = expr;
    while (ps_match(self, ord(TT_ANDAND))) {
        let op_tok = ps_last(self);
        let right = ps_parse_equality_expr(self)?;
        ps_check_reserved_binary_op(self)?;

        let node = expr_node_create(EX_BINARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = current;
        node.expr_b = right;
        current = expr_arena_add(self.expr_arena, node);
    }
    return current;
}

func ps_parse_equality_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_rel_expr(self)?;

    let current = expr;
    while (ps_match_any2(self, ord(TT_EQEQ), ord(TT_NE))) {
        let op_tok = ps_last(self);
        let right = ps_parse_rel_expr(self)?;

        let node = expr_node_create(EX_BINARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = current;
        node.expr_b = right;
        current = expr_arena_add(self.expr_arena, node);
    }
    return current;
}

func ps_parse_rel_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_add_expr(self)?;

    let current = expr;
    while (ps_match_any4(self, ord(TT_LT), ord(TT_GT), ord(TT_LE), ord(TT_GE))) {
        let op_tok = ps_last(self);
        let right = ps_parse_add_expr(self)?;

        let node = expr_node_create(EX_BINARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = current;
        node.expr_b = right;
        current = expr_arena_add(self.expr_arena, node);
    }
    return current;
}

func ps_parse_add_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_mul_expr(self)?;

    let current = expr;
    while (ps_match_any2(self, ord(TT_PLUS), ord(TT_MINUS))) {
        let op_tok = ps_last(self);
        let right = ps_parse_mul_expr(self)?;

        let node = expr_node_create(EX_BINARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = current;
        node.expr_b = right;
        current = expr_arena_add(self.expr_arena, node);
    }
    return current;
}

func ps_parse_mul_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_unary_expr(self)?;

    let current = expr;
    while (ps_match_any3(self, ord(TT_STAR), ord(TT_SLASH), ord(TT_MODULO))) {
        let op_tok = ps_last(self);
        let right = ps_parse_unary_expr(self)?;

        let node = expr_node_create(EX_BINARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = current;
        node.expr_b = right;
        current = expr_arena_add(self.expr_arena, node);
    }
    return current;
}

func ps_parse_unary_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);

    if (ps_match(self, ord(TT_BANG))) {
        let op_tok = ps_last(self);
        let operand = ps_parse_unary_expr(self)?;

        let node = expr_node_create(EX_UNARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = operand;
        return expr_arena_add(self.expr_arena, node);
    }
    if (ps_match(self, ord(TT_MINUS))) {
        let op_tok = ps_last(self);
        let operand = ps_parse_unary_expr(self)?;

        let node = expr_node_create(EX_UNARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = operand;
        return expr_arena_add(self.expr_arena, node);
    }
    if (ps_match(self, ord(TT_STAR))) {
        let op_tok = ps_last(self);
        let operand = ps_parse_unary_expr(self)?;

        let node = expr_node_create(EX_UNARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = operand;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_check(self, ord(TT_TILDE))) {
        let tok = ps_peek(self);
        ps_emit_error(self, "PAR-0226", "[PAR-0226] '~' (bitwise NOT) operator is not yet supported", tok);
        return null;
    }

    return ps_parse_cast_expr(self);
}

func ps_parse_cast_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_postfix_expr(self)?;
    if (ps_match(self, ord(TT_AS))) {
        let target_type = ps_parse_type(self)?;
        let node = expr_node_create(EX_CAST, ps_extend_span(self, start));
        node.expr_a = expr;
        node.type_ref = target_type;
        return expr_arena_add(self.expr_arena, node);
    }
    return expr;
}

func ps_parse_postfix_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let primary = ps_parse_primary_expr(self)?;
    let current = primary;

    while (true) {
        if (ps_match(self, ord(TT_LPAREN))) {
            with (let args: VectorBase*? = id_vec_create(4) => id_vec_free(args)) {
                if (!ps_check(self, ord(TT_RPAREN))) {
                    while (true) {
                        let arg = ps_parse_call_argument(self)?;
                        id_vec_push(args as VectorBase*, arg);
                        if (!ps_match(self, ord(TT_COMMA))) {
                            break;
                        }
                    }
                }
                ps_expect(self, ord(TT_RPAREN), "PAR-0210", "[PAR-0210] expected ')' after arguments")?;

                let node = expr_node_create(EX_CALL, ps_extend_span(self, start));
                node.expr_a = current;
                node.ids = args as VectorBase*;
                args = null;
                current = expr_arena_add(self.expr_arena, node);
                continue;
            }
        }

        if (ps_match(self, ord(TT_LBRACKET))) {
            let index = ps_parse_expr(self)?;
            ps_expect(self, ord(TT_RBRACKET), "PAR-0211", "[PAR-0211] expected ']' after index")?;

            let node = expr_node_create(EX_INDEX, ps_extend_span(self, start));
            node.expr_a = current;
            node.expr_b = index;
            current = expr_arena_add(self.expr_arena, node);
            continue;
        }

        if (ps_match(self, ord(TT_DOT))) {
            let field_tok = ps_expect_ident(self, "PAR-0212", "[PAR-0212] expected field name after '.'")?;

            let node = expr_node_create(EX_FIELD, ps_extend_span(self, start));
            node.expr_a = current;
            node.text_value = token_ident_text(field_tok) as string;
            current = expr_arena_add(self.expr_arena, node);
            continue;
        }

        if (ps_match(self, ord(TT_QUESTION))) {
            let node = expr_node_create(EX_TRY, ps_extend_span(self, start));
            node.expr_a = current;
            current = expr_arena_add(self.expr_arena, node);
            continue;
        }

        break;
    }

    return current;
}

func ps_parse_primary_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let tok = ps_peek(self);

    if (ps_match(self, ord(TT_NEW))) {
        let parsed_type = ps_parse_type(self)?;
        with (let type_ref: TypeRef*? = parsed_type => type_ref_free(type_ref),
              let args: VectorBase*? = null => id_vec_free(args)) {
            if (ps_match(self, ord(TT_LPAREN))) {
                args = id_vec_create(4);
                if (!ps_check(self, ord(TT_RPAREN))) {
                    while (true) {
                        let arg = ps_parse_call_argument(self)?;
                        id_vec_push(args as VectorBase*, arg);
                        if (!ps_match(self, ord(TT_COMMA))) {
                            break;
                        }
                    }
                }
                ps_expect(self, ord(TT_RPAREN), "PAR-0223", "[PAR-0223] expected ')' after arguments to 'new'")?;
            }

            let node = expr_node_create(EX_NEW, ps_extend_span(self, start));
            node.type_ref = type_ref as TypeRef*;
            if (args == null) {
                node.ids = id_vec_create(0);
            } else {
                node.ids = args as VectorBase*;
            }
            type_ref = null;
            args = null;
            return expr_arena_add(self.expr_arena, node);
        }
    }

    if (ps_match_int(self)) {
        let node = expr_node_create(EX_INT, ps_extend_span(self, start));
        node.int_value = token_int_value(tok) as int;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match_byte(self)) {
        let node = expr_node_create(EX_BYTE, ps_extend_span(self, start));
        node.text_value = token_byte_text(tok) as string;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match_string(self)) {
        let node = expr_node_create(EX_STRING, ps_extend_span(self, start));
        node.text_value = token_string_text(tok) as string;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match(self, ord(TT_TRUE))) {
        let node = expr_node_create(EX_BOOL, ps_extend_span(self, start));
        node.bool_value = true;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match(self, ord(TT_FALSE))) {
        let node = expr_node_create(EX_BOOL, ps_extend_span(self, start));
        node.bool_value = false;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match(self, ord(TT_NULL))) {
        let node = expr_node_create(EX_NULL, ps_extend_span(self, start));
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_check_ident(self)) {
        let qualified = ps_try_parse_qualified_name(self);
        if (qualified != null) {
            let q = qualified as QualifiedNameResult*;
            let node = expr_node_create(EX_VAR_REF, ps_extend_span(self, start));
            node.text_value = token_ident_text(q.name_tok) as string;
            node.module_path = q.module_path;
            node.name_qualifier = q.name_qualifier;
            qn_result_free_only_container(q);
            return expr_arena_add(self.expr_arena, node);
        }

        let name_tok = ps_advance(self);
        let node = expr_node_create(EX_VAR_REF, ps_extend_span(self, start));
        node.text_value = token_ident_text(name_tok) as string;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match(self, ord(TT_LPAREN))) {
        let inner = ps_parse_expr(self)?;
        ps_expect(self, ord(TT_RPAREN), "PAR-0224", "[PAR-0224] expected ')' after expression")?;
        let node = expr_node_create(EX_PAREN, ps_extend_span(self, start));
        node.expr_a = inner;
        return expr_arena_add(self.expr_arena, node);
    }

    ps_emit_error(self, "PAR-0225", concat3_s("[PAR-0225] unexpected token in expression: ", token_to_string(tok), ""), tok);
    return null;
}
