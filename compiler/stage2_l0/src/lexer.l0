/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2025-2026 gwz
 */

module lexer;

import std.io;
import std.string;
import std.unit;

import std.text;
import std.vector;
import std.linear_map;
import util.diag;

import tokens;

/* -------------------------------------
   Character classification helpers
   ------------------------------------ */

func is_ident_start(c: byte) -> bool {
    return is_alpha(c) || c == '_';
}

func is_ident_part(c: byte) -> bool {
    return is_alnum(c) || c == '_';
}

func is_escape_char(c: byte) -> bool {
    return c == '\\' || c == '\'' || c == '"' || c == '?' || c == 'a' ||
           c == 'b' || c == 'f' || c == 'n' || c == 'r' || c == 't' || c == 'v';
}

func is_octal_digit(c: byte) -> bool {
    return c >= '0' && c <= '7';
}

func is_hex_digit(c: byte) -> bool {
    return (c >= '0' && c <= '9') ||
           (c >= 'a' && c <= 'f') ||
           (c >= 'A' && c <= 'F');
}

func hex_char_to_int(c: byte) -> int {
    if (c >= '0' && c <= '9') {
        return c - '0';
    } else if (c >= 'a' && c <= 'f') {
        return 10 + (c - 'a');
    } else if (c >= 'A' && c <= 'F') {
        return 10 + (c - 'A');
    }
    return -1; // Should not reach here if input is valid hex digit
}

/* ------------------------------------
   Lexer State and functions
   ------------------------------------ */

/**
 * Lexer state object that keeps track of the current position in the source code being lexed.
 */
struct LexerState {
    source: string;
    filename: string;
    length: int;
    index: int;
    line: int;
    column: int;
    prev_kind: TokenType;
    diags: DiagCollector*;
}

func ls_create(source: string, filename: string) -> LexerState* {
    let self = new LexerState(
        source,
        filename,
        len_s(source),
        0,
        1,
        1,
        TT_EOF,
        diag_create()
    );
    return self;
}

func ls_has_errors(self: LexerState*) -> bool {
    return diag_has_errors(self.diags);
}

func ls_emit_error(self: LexerState*, code: string, message: string, line: int, column: int, line_end: int, column_end: int) {
    diag_error(self.diags, "Lexer", code, message, self.filename, line, column, line_end, column_end);
}

func ls_free(self: LexerState*) {
    diag_free(self.diags);
    drop self;
}

func ls_at_end(self: LexerState*) -> bool {
    return self.index >= self.length;
}

func ls_peek(self: LexerState*) -> byte {
    if (ls_at_end(self)) {
        return '\0';
    }
    return char_at_s(self.source, self.index);
}

func ls_peek_next(self: LexerState*) -> byte {
    if (self.index + 1 >= self.length) {
        return '\0';
    }
    return char_at_s(self.source, self.index + 1);
}

func ls_advance(self: LexerState*) -> byte {
    let current_char = ls_peek(self);
    if (!ls_at_end(self)) {
        self.index = self.index + 1;
        if (current_char == '\n') {
            self.line = self.line + 1;
            self.column = 1;
        } else {
            self.column = self.column + 1;
        }
    }
    return current_char;
}

/* ------------------------------------
   Auxiliary data structures
   ------------------------------------ */

// Struct to represent a valid byte or Unicode code point escape sequence and its corresponding value
struct EscapedChar {
    escape_str: string; // The full escape sequence as it appears in the source (e.g., "\\n", "\\x1B", etc.)
    char_value: int;    // The actual character value represented by the escape sequence (e.g., 10 for "\\n", 27 for "\\x1B")
}

/* ------------------------------------
   Main API
   ------------------------------------ */

/**
 * Tokenizes the input source code and returns a vector of tokens.
 * If a lexing error occurs, the error field in the LexerState will be set and null will be returned.
 */
func tokenize(self: LexerState*) -> TokenVector? {
    let tokens = tv_create();
    while (true) {
        let token = ls_next_token(self)?;
        tv_push(tokens, token);
        self.prev_kind = token.token_type;
        match (token.token_type) {
            TT_EOF => { break; }
            _ => {}
        }
    }
    return tokens;
}

/**
 * Reads the next token from the input source code.
 * Returns a Token if successful, or `null` if a lexing error occurs,
 * in which case the error field in the LexerState will be set.
 */
func ls_next_token(self: LexerState*) -> Token? {
    ls_skip_whitespace_and_comments(self)?;

    let start_index = self.index;
    let start_line = self.line;
    let start_column = self.column;

    if (ls_at_end(self)) {
        return Token(TT_EOF, self.index, self.line, self.column);
    }

    let c = ls_advance(self);

    // identifiers / keywords and underscore wildcard
    if (is_ident_start(c)) {
        with (let cb = cb_create() => cb_free(cb)) {
            cb_append(cb, c);
            while (true) {
                if (is_ident_part(ls_peek(self))) {
                    cb_append(cb, ls_advance(self));
                } else {
                    break;
                }
            }
            return ident_to_token(cb_to_string(cb), start_index, start_line, start_column);
        }
    }

    // numbers (only integers for now)
    if (is_digit(c)) {
        return ls_read_number(self, c, false, start_index, start_line, start_column);
    }

    case(c){
        '"' => return ls_read_string_literal(self, start_index, start_line, start_column);

        '\'' => return ls_read_byte_literal(self, start_index, start_line, start_column);

        // punctuation and operators with lookahead
        '-' => {
            if (ls_peek(self) == '>') {
                ls_advance(self);
                return Token(TT_ARROW_FUNC, start_index, start_line, start_column);
            }
            else if (is_digit(ls_peek(self)) && !is_expr_ending_token_type(self.prev_kind)) {
                // Negative number literal if we are in a unary operator context,
                // e.g. "f(-5)": here -5 is a negative number, but "x-5" is x MINUS 5
                return ls_read_number(self, ls_advance(self), true, start_index, start_line, start_column);
            }
            return Token(TT_MINUS, start_index, start_line, start_column);
        }

        '(' => return Token(TT_LPAREN, start_index, start_line, start_column);

        ')' => return Token(TT_RPAREN, start_index, start_line, start_column);

        '{' => return Token(TT_LBRACE, start_index, start_line, start_column);

        '}' => return Token(TT_RBRACE, start_index, start_line, start_column);

        '[' => return Token(TT_LBRACKET, start_index, start_line, start_column);

        ']' => return Token(TT_RBRACKET, start_index, start_line, start_column);

        ',' => return Token(TT_COMMA, start_index, start_line, start_column);

        ';' => return Token(TT_SEMI, start_index, start_line, start_column);

        ':' => {
            if (ls_peek(self) == ':') {
                ls_advance(self);
                return Token(TT_DOUBLE_COLON, start_index, start_line, start_column);
            }
            return Token(TT_COLON, start_index, start_line, start_column);
        }

        '.' => return Token(TT_DOT, start_index, start_line, start_column);

        '?' => return Token(TT_QUESTION, start_index, start_line, start_column);

        '=' => {
            case(ls_peek(self)) {
                '>' => {
                    ls_advance(self);
                    return Token(TT_ARROW_MATCH, start_index, start_line, start_column);
                }
                '=' => {
                    ls_advance(self);
                    return Token(TT_EQEQ, start_index, start_line, start_column);
                }
                else return Token(TT_EQ, start_index, start_line, start_column);
            }
        }

        '!' => {
            if (ls_peek(self) == '=') {
                ls_advance(self);
                return Token(TT_NE, start_index, start_line, start_column);
            }
            return Token(TT_BANG, start_index, start_line, start_column);
        }

        '<' => {
            case(ls_peek(self)) {
                 '=' => {
                    ls_advance(self);
                    return Token(TT_LE, start_index, start_line, start_column);
                }
                '<' => {
                    ls_advance(self);
                    return Token(TT_LSHIFT, start_index, start_line, start_column);
                }
                else return Token(TT_LT, start_index, start_line, start_column);
            }
        }

        '>' => {
            case(ls_peek(self)) {
                 '=' => {
                    ls_advance(self);
                    return Token(TT_GE, start_index, start_line, start_column);
                }
                '>' => {
                    ls_advance(self);
                    return Token(TT_RSHIFT, start_index, start_line, start_column);
                }
                else return Token(TT_GT, start_index, start_line, start_column);
            }
        }

        '&' => {
            if (ls_peek(self) == '&') {
                ls_advance(self);
                return Token(TT_ANDAND, start_index, start_line, start_column);
            }
            return Token(TT_AMP, start_index, start_line, start_column);
        }

        '|' => {
            if (ls_peek(self) == '|') {
                ls_advance(self);
                return Token(TT_OROR, start_index, start_line, start_column);
            }
            return Token(TT_PIPE, start_index, start_line, start_column);
        }

        '^' => return Token(TT_CARET, start_index, start_line, start_column);

        '~' => return Token(TT_TILDE, start_index, start_line, start_column);

        '+' => return Token(TT_PLUS, start_index, start_line, start_column);

        '*' => return Token(TT_STAR, start_index, start_line, start_column);

        '/' => return Token(TT_SLASH, start_index, start_line, start_column);

        '%' => return Token(TT_MODULO, start_index, start_line, start_column);

        else {
            // If we reach here, it's an unrecognized character
            ls_emit_error(self, "LEX-0040", concat3_s("unexpected character '", byte_to_s(c), "'"), start_line, start_column, start_line, start_column + 1);
            return null;
        }
    }
}

/**
 * Reads a byte literal from the input, starting after the opening single quote.
 * Handles escape sequences and validates that the literal represents a single byte.
 * Returns a Token of type TT_BYTE if successful, or `null` if a lexing error occurs,
 * in which case the error field in the LexerState will be set.
 */
func ls_read_byte_literal(self: LexerState*, start_index: int, start_line: int, start_column: int) -> Token? {
    with (let cb = cb_create() => cb_free(cb)) {
        let c = ls_peek(self);
        let byte_value: byte = '\0';

        if (c == '\\') {
            let esc = ls_read_valid_char_escape(self, true)?;
            cb_append_s(cb, esc.escape_str);
            // We know the following is safe because ls_read_valid_char_escape checks the range for single-byte escapes
            byte_value = esc.char_value as byte;
        } else if (c == '\0' || c == '\n') {
            ls_emit_error(self, "LEX-0020", "unterminated byte literal", start_line, start_column, start_line, start_column + 1);
            return null;
        } else {
            byte_value = ls_advance(self);
            cb_append(cb, byte_value);
        }

        if (ls_peek(self) != '\'') {
            ls_emit_error(self, "LEX-0021", "invalid byte literal, expected closing single quote", start_line, start_column, self.line, self.column);
            return null; // Invalid byte literal
        }
        ls_advance(self); // consume closing quote

        let byte_str = cb_to_string(cb);
        return Token(TT_BYTE(byte_str, byte_value), start_index, start_line, start_column);
    }
}

/**
 * Reads a string literal from the input, starting after the opening double quote.
 * Handles escape sequences and validates that the string is properly terminated.
 * Returns a Token of type TT_STRING if successful, or `null` if a lexing error occurs,
 * in which case the error field in the LexerState will be set.
 */
func ls_read_string_literal(self: LexerState*, start_index: int, start_line: int, start_column: int) -> Token? {
    with (let cb = cb_create() => cb_free(cb),
          let vb = cb_create() => cb_free(vb)) {
        while (true) {
            let c = ls_peek(self);
            if (c == '\0' || c == '\n') { // EOF or newline before closing quote
                ls_emit_error(self, "LEX-0010", "unterminated string literal", start_line, start_column, self.line, self.column);
                return null; // Unterminated string
            }
            case (c) {
                '"' => {
                    ls_advance(self); // consume closing quote
                    break; // End of string
                }
                '\\' => {
                    let esc = ls_read_valid_char_escape(self, false)?;
                    cb_append_s(cb, esc.escape_str);
                    if (esc.char_value <= 127) {
                        cb_append(vb, esc.char_value as byte);
                    } else {
                        // FIXME handle Unicode code points > 127 directly in the future
                        cb_append_s(vb, esc.escape_str);
                    }
                    continue;
                }
                else {
                    cb_append(cb, c);
                    cb_append(vb, ls_advance(self));
                }
            }
        }
        let lit_value = cb_to_string(cb); // the literal string value as it appears in the source
        let str_value = cb_to_string(vb); // the actual string value with escape sequences processed
        return Token(TT_STRING(lit_value, str_value), start_index, start_line, start_column);
    }
}

/**
 * Reads a valid escape sequence from the input, starting after the backslash.
 * Validates that the escape sequence is well-formed and returns both the original escape string and its
 * corresponding character value.
 * If `single_byte` is true, also validates that the resulting character value can fit in a single byte (0-255).
 * Returns an EscapedChar struct if successful, or `null` if an invalid escape sequence is encountered,
 * in which case the error field in the LexerState will be set.
 */
func ls_read_valid_char_escape(self: LexerState*, single_byte: bool) -> EscapedChar? {
    let char_value: int = 0;
    with (let cb = cb_create() => cb_free(cb)) {
        cb_append(cb, ls_advance(self)); // the backslash

        let c = ls_peek(self);
        if (is_escape_char(c)) {
            cb_append(cb, ls_advance(self));
        }
        else if (c == 'x') {
            // Hexadecimal escape sequence: \xH+ (at least 1 hex digit)
            cb_append(cb, ls_advance(self)); // consume 'x'
            let hex_digits = 0;
            while (is_hex_digit(ls_peek(self))) {
                let digit = ls_peek(self);
                cb_append(cb, ls_advance(self));
                hex_digits = hex_digits + 1;
                char_value = char_value * 16 + hex_char_to_int(digit);
            }
            if (hex_digits < 1) {
                ls_emit_error(self, "LEX-0050", "invalid hexadecimal escape sequence", self.line, self.column, self.line, self.column);
                return null;
            }
            if (single_byte && char_value > 255) {
                ls_emit_error(self, "LEX-0031", concat3_s("character literal hexadecimal escape out of range (0-255): '\\x",
                                               int_to_string_base(char_value, 16), "'"), self.line, self.column, self.line, self.column);
                return null;
            }
        }
        else if (c == 'u' || c == 'U') {
            // Unicode escape sequence: \uHHHH or \UHHHHHHHH (4 or 8 hex digits)
            cb_append(cb, ls_advance(self)); // consume 'u' or 'U'
            let hex_digits = 0;
            let required_digits = 4;
            if (c == 'U') required_digits = 8;
            while (is_hex_digit(ls_peek(self)) && hex_digits < required_digits) {
                let digit = ls_peek(self);
                cb_append(cb, ls_advance(self));
                hex_digits = hex_digits + 1;
                char_value = char_value * 16 + hex_char_to_int(digit);
            }
            if (hex_digits != required_digits) {
                let error_code = "LEX-0051"; // u
                if (c == 'U') error_code = "LEX-0052"; // U
                with (let sb = sb_create() => sb_free(sb)) {
                    sb_append(sb, "invalid Unicode escape sequence, expected ");
                    sb_append_int(sb, required_digits);
                    sb_append(sb, " hex digits");
                    ls_emit_error(self, error_code, sb_to_string(sb), self.line, self.column, self.line, self.column);
                }
                return null;
            }
            if (char_value > 1114111) { // 0x10FFFF
                ls_emit_error(self, "LEX-0054", "Unicode code point out of range (must be <= 0x10FFFF)", self.line, self.column, self.line, self.column);
                return null;
            }
            if (single_byte) {
                if (char_value > 127) {
                    ls_emit_error(self, "LEX-0030", "character literal must represent a single byte", self.line, self.column, self.line, self.column);
                    return null;
                }
                // For single-byte character literals, convert to the \xHH form
                let hex_str = int_to_string_base(char_value, 16);
                cb_clear(cb);
                cb_append_s(cb, "\\x");
                if (char_value < 16) {
                    cb_append(cb, '0'); // Pad with leading zero if needed
                }
                cb_append_s(cb, hex_str);
            }
        }
        else if (is_octal_digit(c)) {
            // Octal escape sequence: \ooo (up to 3 octal digits)
            let octal_digits = 0;
            while (octal_digits < 3 && is_octal_digit(ls_peek(self))) {
                let digit = ls_peek(self);
                cb_append(cb, ls_advance(self));
                octal_digits = octal_digits + 1;
                char_value = char_value * 8 + (digit - '0');
                if (char_value > 255) {
                    ls_emit_error(self, "LEX-0053", "octal escape sequence out of range (must be <= 377)", self.line, self.column, self.line, self.column);
                    return null;
                }
            }
        }
        else {
            ls_emit_error(self, "LEX-0059", concat3_s("unknown escape sequence '\\", byte_to_s(c), "'"), self.line, self.column, self.line, self.column);
            return null;
        }

        let escape_str = cb_to_string(cb);
        return EscapedChar(escape_str, char_value);
    } // with
}

/**
 * Reads an integer literal from the input, starting with the first digit character.
 * Validates that the literal is well-formed and does not contain invalid characters immediately following it.
 * Also checks for integer overflow and ensures the value fits within a 32-bit signed integer range.
 * Returns a Token of type TT_INT if successful, or `null` if a lexing error occurs, in which case the error field
 * in the LexerState will be set.
 */
func ls_read_number(self: LexerState*, first_char: byte, is_negative: bool,
                    start_index: int, start_line: int, start_column: int) -> Token? {
    with (let cb = cb_create() => cb_free(cb)) {
        if (is_negative) {
            cb_append(cb, '-');
        }
        cb_append(cb, first_char);
        while (is_digit(ls_peek(self))) {
            cb_append(cb, ls_advance(self));
        }
        let number_str = cb_to_string(cb);

        // Check for invalid characters immediately following the number (e.g., "123abc")
        if (is_ident_start(ls_peek(self))) {
            ls_emit_error(self, "LEX-0061", concat3_s("invalid character '", byte_to_s(ls_peek(self)), "' after integer literal"), start_line, start_column, self.line, self.column);
            return null;
        }

        // Check for integer overflow
        let number_value : int? = string_to_int(number_str);
        if (number_value == null) {
            ls_emit_error(self, "LEX-0060", concat3_s("integer literal '", number_str, "' exceeds 32-bit signed range"), start_line, start_column, self.line, self.column);
            return null;
        }

        return Token(TT_INT(number_str, number_value as int), start_index, start_line, start_column);
    }
}

/**
 * Skips over any whitespace characters and comments in the input until it reaches a non-whitespace, non-comment
 * character or the end of the input.
 * Handles both line comments and block comments.
 * Returns std.unit::present() if successful, or `null` if an unterminated block comment is encountered,
 * in which case the error field in the LexerState will be set.
 */
func ls_skip_whitespace_and_comments(self: LexerState*) -> Unit? {
    while (true) {
        let c = ls_peek(self);
        if (is_space(c)) {
            ls_advance(self);
            continue;
        } else if (c == '/') {
            case (ls_peek_next(self)) {
                '/' => {
                    // line comment
                    while (ls_peek(self) != '\n' && !ls_at_end(self)) {
                        ls_advance(self);
                    }
                    continue;
                }
                '*' => {
                    // block comment
                    ls_advance(self); // consume '/'
                    ls_advance(self); // consume '*'
                    while (true) {
                        if (ls_at_end(self)) {
                            ls_emit_error(self, "LEX-0070", "unterminated block comment", self.line, self.column, self.line, self.column);
                            return null; // Unterminated comment
                        }
                        if (ls_peek(self) == '*' && ls_peek_next(self) == '/') {
                            ls_advance(self); // consume '*'
                            ls_advance(self); // consume '/'
                            break;
                        }
                        ls_advance(self);
                    }
                }
                else break; // Not a comment
            }
        } else break; // Other non-whitespace, non-comment character
    }
    return std.unit::present(); // Success
}
