/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2026 gwz
 */

module driver;

import sys.rt;

import std.string;
import std.io;
import std.text;
import std.vector;
import util.diag;

import util.strings;
import source_paths;
import parser;
import ast;

struct DriverUnit {
    module_name: string;
    path: string;
    parse_result: ParseResult*;
}

struct DriverState {
    entry_module: string;
    units: VectorBase*; // DriverUnit*
    loaded: VectorString*; // used during analysis, inert afterward
    diags: DiagCollector*;
    source_names: VectorString*; // source cache: file paths
    source_texts: VectorString*; // source cache: file contents
}

func dr_unit_free(self: DriverUnit*) {
    parse_result_free(self.parse_result);
    drop self;
}

func dr_units_free(units: VectorBase*?) {
    if (units == null) {
        return;
    }

    let v = units as VectorBase*;
    for (let i = 0; i < vec_size(v); i = i + 1) {
        let unit = ptr_vec_get(v, i) as DriverUnit*;
        dr_unit_free(unit);
    }
    vec_free(v);
}

func driver_state_free(self: DriverState*) {
    dr_units_free(self.units);
    vs_free(self.loaded);
    diag_free(self.diags);
    vs_free(self.source_names);
    vs_free(self.source_texts);
    drop self;
}

func driver_has_errors(self: DriverState*) -> bool {
    return diag_has_errors(self.diags);
}

func driver_diag_count(self: DriverState*) -> int {
    return diag_count(self.diags);
}

func driver_diag_get(self: DriverState*, index: int) -> Diagnostic* {
    return diag_get(self.diags, index);
}

func driver_unit_count(self: DriverState*) -> int {
    return vec_size(self.units);
}

func driver_unit_get(self: DriverState*, index: int) -> DriverUnit* {
    return ptr_vec_get(self.units, index) as DriverUnit*;
}

func driver_find_unit(self: DriverState*, module_name: string) -> DriverUnit*? {
    for (let i = 0; i < vec_size(self.units); i = i + 1) {
        let unit = ptr_vec_get(self.units, i) as DriverUnit*;
        if (eq_s(unit.module_name, module_name)) {
            return unit;
        }
    }
    return null;
}

func driver_module_names_sorted(self: DriverState*) -> VectorString* {
    let out = vs_create(vec_size(self.units));
    for (let i = 0; i < vec_size(self.units); i = i + 1) {
        let unit = ptr_vec_get(self.units, i) as DriverUnit*;
        vs_push(out, unit.module_name);
    }
    vs_sort(out);
    return out;
}

func dr_copy_parse_diags(dst: DiagCollector*, pr: ParseResult*) {
    for (let i = 0; i < parse_diag_count(pr); i = i + 1) {
        diag_copy(dst, parse_diag_get(pr, i));
    }
}

func dr_emit_error(diags: DiagCollector*, code: string, message: string, filename: string) {
    diag_error(diags, "Driver", code, message, filename, 0, 0, 0, 0);
}

func dr_vs_has(items: VectorString*, module_name: string) -> bool {
    for (let i = 0; i < vs_size(items); i = i + 1) {
        if (eq_s(vs_get(items, i), module_name)) {
            return true;
        }
    }
    return false;
}

func dr_mark_loaded(loaded: VectorString*, module_name: string) {
    if (!dr_vs_has(loaded, module_name)) {
        vs_push(loaded, module_name);
    }
}

func dr_load_module(state: DriverState*, search_paths: SourceSearchPaths*, loading_chain: string,
                    module_name: string) -> bool {
    if (dr_vs_has(state.loaded, module_name)) {
        return true;
    }

    let cycle_token = concat3_s("|", module_name, "|");
    if (contains_s(loading_chain, cycle_token)) {
        dr_emit_error(state.diags, "DRV-2030", concat3_s("Cyclic import detected involving '", module_name, "'"), "");
        return false;
    }

    let next_loading_chain = concat3_s(loading_chain, module_name, "|");
    let ok = true;

    let path_opt = sp_resolve(search_paths, module_name);
    if (path_opt == null) {
        dr_emit_error(state.diags, "DRV-2010", concat3_s("Module '", module_name, "' not found in system_roots or project_roots"), "");
        ok = false;
    } else {
        let path = path_opt as string;

        let source_opt = read_file(path);
        if (source_opt == null) {
            dr_emit_error(state.diags, "DRV-2020", concat_s("cannot read source file: ", path), path);
            ok = false;
        } else {
            let source_raw = source_opt as string;
            let source = us_strip_utf8_bom(source_raw);

            vs_push(state.source_names, path);
            vs_push(state.source_texts, source);

            let pr = parse_module_source(source, path);

            let unit = new DriverUnit(module_name, path, pr);
            ptr_vec_push(state.units, unit as void*);

            dr_copy_parse_diags(state.diags, pr);

            if (pr.root_module == null) {
                ok = false;
            } else {
                let mod = pr.root_module as Module*;
                if (!eq_s(mod.name, module_name)) {
                    let msg = concat4_s("module name mismatch: file ", path, " declares '", mod.name);
                    dr_emit_error(state.diags, "DRV-2040", concat4_s(msg, "' but was loaded as '", module_name, "'"), path);
                    ok = false;
                } else {
                    for (let i = 0; i < vec_size(mod.imports); i = i + 1) {
                        let imp = ptr_vec_get(mod.imports, i) as Import*;
                        let child_ok = dr_load_module(state, search_paths, next_loading_chain, imp.name);
                        if (!child_ok) {
                            ok = false;
                        }
                    }
                }
            }

            if (parse_has_errors(pr)) {
                ok = false;
            }
        }
    }

    dr_mark_loaded(state.loaded, module_name);
    return ok;
}

func driver_analyze_entry(search_paths: SourceSearchPaths*, entry_module: string) -> DriverState* {
    let state = new DriverState(
        entry_module, ptr_vec_create(8), vs_create(8),
        diag_create(), vs_create(4), vs_create(4)
    );
    dr_load_module(state, search_paths, "|", entry_module);
    return state;
}
