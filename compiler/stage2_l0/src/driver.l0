/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2026 gwz
 */

module driver;

import sys.rt;

import std.string;
import std.io;
import std.text;
import std.vector;
import util.diag;

import util.strings;
import source_paths;
import parser;
import ast;

struct DriverUnit {
    module_name: string;
    path: string;
    parse_result: ParseResult*;
}

struct DriverResult {
    entry_module: string;
    units: VectorBase*; // DriverUnit*
    diags: DiagCollector*;
}

func dr_unit_free(self: DriverUnit*) {
    parse_result_free(self.parse_result);
    drop self;
}

func dr_units_free(units: VectorBase*?) {
    if (units == null) {
        return;
    }

    let v = units as VectorBase*;
    for (let i = 0; i < vec_size(v); i = i + 1) {
        let unit = ptr_vec_get(v, i) as DriverUnit*;
        dr_unit_free(unit);
    }
    vec_free(v);
}

func driver_result_free(self: DriverResult*) {
    dr_units_free(self.units);
    diag_free(self.diags);
    drop self;
}

func driver_result_has_errors(self: DriverResult*) -> bool {
    return diag_has_errors(self.diags);
}

func driver_diag_count(self: DriverResult*) -> int {
    return diag_count(self.diags);
}

func driver_diag_get(self: DriverResult*, index: int) -> Diagnostic* {
    return diag_get(self.diags, index);
}

func driver_unit_count(self: DriverResult*) -> int {
    return vec_size(self.units);
}

func driver_unit_get(self: DriverResult*, index: int) -> DriverUnit* {
    return ptr_vec_get(self.units, index) as DriverUnit*;
}

func driver_find_unit(self: DriverResult*, module_name: string) -> DriverUnit*? {
    for (let i = 0; i < vec_size(self.units); i = i + 1) {
        let unit = ptr_vec_get(self.units, i) as DriverUnit*;
        if (eq_s(unit.module_name, module_name)) {
            return unit;
        }
    }
    return null;
}

func driver_module_names_sorted(self: DriverResult*) -> VectorString* {
    let out = vs_create(vec_size(self.units));
    for (let i = 0; i < vec_size(self.units); i = i + 1) {
        let unit = ptr_vec_get(self.units, i) as DriverUnit*;
        vs_push(out, unit.module_name);
    }
    vs_sort(out);
    return out;
}

func dr_copy_diag(dst: DiagCollector*, src: Diagnostic*) {
    match (src.severity) {
        Error => {
            diag_error(dst, src.phase, src.code, src.message, src.filename, src.line, src.column, src.line_end, src.column_end);
        }
        Warning => {
            diag_warn(dst, src.phase, src.code, src.message, src.filename, src.line, src.column, src.line_end, src.column_end);
        }
        Note => {
            diag_note(dst, src.phase, src.code, src.message, src.filename, src.line, src.column, src.line_end, src.column_end);
        }
    }
}

func dr_copy_parse_diags(dst: DiagCollector*, pr: ParseResult*) {
    for (let i = 0; i < parse_diag_count(pr); i = i + 1) {
        let d = parse_diag_get(pr, i);
        dr_copy_diag(dst, d);
    }
}

func dr_emit_error(diags: DiagCollector*, code: string, message: string, filename: string) {
    diag_error(diags, "Driver", code, message, filename, 0, 0, 0, 0);
}

func dr_vs_has(items: VectorString*, module_name: string) -> bool {
    for (let i = 0; i < vs_size(items); i = i + 1) {
        if (eq_s(vs_get(items, i), module_name)) {
            return true;
        }
    }
    return false;
}

func dr_mark_loaded(loaded: VectorString*, module_name: string) {
    if (!dr_vs_has(loaded, module_name)) {
        vs_push(loaded, concat_s(module_name, ""));
    }
}

func dr_load_module(search_paths: SourceSearchPaths*, units: VectorBase*, loaded: VectorString*, loading_chain: string,
                    diags: DiagCollector*, module_name: string) -> bool {
    if (dr_vs_has(loaded, module_name)) {
        return true;
    }

    let cycle_token = concat3_s("|", module_name, "|");
    if (contains_s(loading_chain, cycle_token)) {
        dr_emit_error(diags, "DRV-2030", concat3_s("Cyclic import detected involving '", module_name, "'"), "");
        return false;
    }

    let next_loading_chain = concat3_s(loading_chain, module_name, "|");
    let ok = true;

    let path_opt = sp_resolve(search_paths, module_name);
    if (path_opt == null) {
        dr_emit_error(diags, "DRV-2010", concat3_s("Module '", module_name, "' not found in system_roots or project_roots"), "");
        ok = false;
    } else {
        let path = path_opt as string;

        let source_opt = read_file(path);
        if (source_opt == null) {
            dr_emit_error(diags, "DRV-2020", concat_s("cannot read source file: ", path), path);
            ok = false;
        } else {
            let source_raw = source_opt as string;
            let source = us_strip_utf8_bom(source_raw);

            let pr = parse_module_source(source, path);

            let unit = new DriverUnit(concat_s(module_name, ""), concat_s(path, ""), pr);
            ptr_vec_push(units, unit as void*);

            dr_copy_parse_diags(diags, pr);

            if (pr.root_module == null) {
                ok = false;
            } else {
                let mod = pr.root_module as Module*;
                if (!eq_s(mod.name, module_name)) {
                    let msg = concat4_s("module name mismatch: file ", path, " declares '", mod.name);
                    dr_emit_error(diags, "DRV-2040", concat4_s(msg, "' but was loaded as '", module_name, "'"), path);
                    ok = false;
                } else {
                    for (let i = 0; i < vec_size(mod.imports); i = i + 1) {
                        let imp = ptr_vec_get(mod.imports, i) as Import*;
                        let child_ok = dr_load_module(search_paths, units, loaded, next_loading_chain, diags, concat_s(imp.name, ""));
                        if (!child_ok) {
                            ok = false;
                        }
                    }
                }
            }

            if (parse_has_errors(pr)) {
                ok = false;
            }
        }
    }

    dr_mark_loaded(loaded, module_name);
    return ok;
}

func driver_analyze_entry(search_paths: SourceSearchPaths*, entry_module: string) -> DriverResult* {
    let units = ptr_vec_create(8);
    let loaded = vs_create(8);
    let diags = diag_create();

    dr_load_module(search_paths, units, loaded, "|", diags, concat_s(entry_module, ""));

    vs_free(loaded);
    return new DriverResult(entry_module, units, diags);
}
