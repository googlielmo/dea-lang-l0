/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2026 gwz
 */

module parser;

import tokens;
import ast;
import parser.shared;
import parser.decl;

struct ParseError {
    code: string;
    message: string;
    line: int;
    column: int;
    filename: string;
}

enum ParseErrorState {
    ParseNoError;
    ParseHasError(err: ParseError);
}

struct ParseResult {
    root_module: Module*?;
    expr_arena: ExprArena*;
    stmt_arena: StmtArena*;
    pattern_arena: PatternArena*;
    error: ParseErrorState;
}

func parse_result_free(self: ParseResult*) {
    if (self.root_module != null) {
        module_free(self.root_module as Module*);
    }
    expr_arena_free(self.expr_arena);
    stmt_arena_free(self.stmt_arena);
    pattern_arena_free(self.pattern_arena);
    drop self;
}

func impl_error_to_public(err: ImplParseErrorState) -> ParseErrorState {
    let out = ParseNoError;
    match (err) {
        ImplParseNoError => {
            out = ParseNoError;
        }
        ImplParseHasError(e) => {
            let pub = ParseError(e.code, e.message, e.line, e.column, e.filename);
            out = ParseHasError(pub);
        }
    }
    return out;
}

func impl_result_to_public(self: ImplParseResult*) -> ParseResult* {
    let result = new ParseResult(
        self.root_module,
        self.expr_arena,
        self.stmt_arena,
        self.pattern_arena,
        impl_error_to_public(self.error)
    );
    drop self;
    return result;
}

func parse_module_tokens(tokens: TokenVector, filename: string) -> ParseResult* {
    let impl = parser.decl::impl_parse_module_tokens(tokens, filename);
    return impl_result_to_public(impl);
}

func parse_module_source(source: string, filename: string) -> ParseResult* {
    let impl = parser.decl::impl_parse_module_source(source, filename);
    return impl_result_to_public(impl);
}
