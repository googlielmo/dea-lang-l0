/*
 * SPDX-License-Identifier: MIT OR Apache-2.0
 * Copyright (c) 2026 gwz
 */

module parser;

import std.string;
import std.unit;
import std.assert;

import util.text;
import util.vector;

import tokens;
import lexer;
import ast;

/* ------------------------------------
   Parse error/result
   ------------------------------------ */

struct ParseError {
    code: string;
    message: string;
    line: int;
    column: int;
    filename: string;
}

enum ParseErrorState {
    ParseNoError;
    ParseHasError(err: ParseError);
}

struct ParseResult {
    root_module: Module*?;
    expr_arena: ExprArena*;
    stmt_arena: StmtArena*;
    pattern_arena: PatternArena*;
    error: ParseErrorState;
}

func parse_result_free(self: ParseResult*) {
    if (self.root_module != null) {
        module_free(self.root_module as Module*);
    }
    expr_arena_free(self.expr_arena);
    stmt_arena_free(self.stmt_arena);
    pattern_arena_free(self.pattern_arena);
    drop self;
}

/* ------------------------------------
   Parser state
   ------------------------------------ */

struct ParserState {
    tokens: TokenVector;
    index: int;
    filename: string;
    error: ParseErrorState;

    expr_arena: ExprArena*;
    stmt_arena: StmtArena*;
    pattern_arena: PatternArena*;
}

func ps_create(tokens: TokenVector, filename: string) -> ParserState* {
    return new ParserState(
        tokens,
        0,
        filename,
        ParseNoError,
        expr_arena_create(128),
        stmt_arena_create(128),
        pattern_arena_create(64)
    );
}

func ps_destroy(self: ParserState*) {
    drop self;
}

func ps_set_error(self: ParserState*, code: string, message: string, tok: Token) {
    if (ord(self.error) == ord(ParseNoError)) {
        self.error = ParseHasError(ParseError(code, message, tok.line, tok.column, self.filename));
    }
}

func ps_has_error(self: ParserState*) -> bool {
    return ord(self.error) != ord(ParseNoError);
}

/* ------------------------------------
   Token utilities
   ------------------------------------ */

func tok_is(tok: Token, kind_ord: int) -> bool {
    return ord(tok.token_type) == kind_ord;
}

func tok_is_ident(tok: Token) -> bool {
    match (tok.token_type) {
        TT_IDENT(t) => { return true; }
        _ => { return false; }
    }
}

func tok_is_int(tok: Token) -> bool {
    match (tok.token_type) {
        TT_INT(t, v) => { return true; }
        _ => { return false; }
    }
}

func tok_is_byte(tok: Token) -> bool {
    match (tok.token_type) {
        TT_BYTE(t, v) => { return true; }
        _ => { return false; }
    }
}

func tok_is_string(tok: Token) -> bool {
    match (tok.token_type) {
        TT_STRING(t, v) => { return true; }
        _ => { return false; }
    }
}

func tok_is_future_extension(tok: Token) -> bool {
    return ord(tok.token_type) == ord(TT_FUTURE_EXTENSION);
}

func ps_peek(self: ParserState*) -> Token {
    return tv_get(self.tokens, self.index);
}

func ps_last(self: ParserState*) -> Token {
    if (self.index > 0) {
        return tv_get(self.tokens, self.index - 1);
    }
    return tv_get(self.tokens, 0);
}

func ps_at_end(self: ParserState*) -> bool {
    return tok_is(ps_peek(self), ord(TT_EOF));
}

func ps_advance(self: ParserState*) -> Token {
    let tok = ps_peek(self);
    if (!ps_at_end(self)) {
        self.index = self.index + 1;
    }
    return tok;
}

func ps_check(self: ParserState*, kind_ord: int) -> bool {
    return tok_is(ps_peek(self), kind_ord);
}

func ps_match(self: ParserState*, kind_ord: int) -> bool {
    if (ps_check(self, kind_ord)) {
        ps_advance(self);
        return true;
    }
    return false;
}

func ps_match_any2(self: ParserState*, k1: int, k2: int) -> bool {
    if (ps_match(self, k1)) {
        return true;
    }
    if (ps_match(self, k2)) {
        return true;
    }
    return false;
}

func ps_match_any3(self: ParserState*, k1: int, k2: int, k3: int) -> bool {
    if (ps_match(self, k1)) {
        return true;
    }
    if (ps_match(self, k2)) {
        return true;
    }
    if (ps_match(self, k3)) {
        return true;
    }
    return false;
}

func ps_match_any4(self: ParserState*, k1: int, k2: int, k3: int, k4: int) -> bool {
    if (ps_match(self, k1)) {
        return true;
    }
    if (ps_match(self, k2)) {
        return true;
    }
    if (ps_match(self, k3)) {
        return true;
    }
    if (ps_match(self, k4)) {
        return true;
    }
    return false;
}

func ps_check_ident(self: ParserState*) -> bool {
    return tok_is_ident(ps_peek(self));
}

func ps_match_ident(self: ParserState*) -> bool {
    if (ps_check_ident(self)) {
        ps_advance(self);
        return true;
    }
    return false;
}

func ps_check_int(self: ParserState*) -> bool {
    return tok_is_int(ps_peek(self));
}

func ps_match_int(self: ParserState*) -> bool {
    if (ps_check_int(self)) {
        ps_advance(self);
        return true;
    }
    return false;
}

func ps_check_byte(self: ParserState*) -> bool {
    return tok_is_byte(ps_peek(self));
}

func ps_match_byte(self: ParserState*) -> bool {
    if (ps_check_byte(self)) {
        ps_advance(self);
        return true;
    }
    return false;
}

func ps_check_string(self: ParserState*) -> bool {
    return tok_is_string(ps_peek(self));
}

func ps_match_string(self: ParserState*) -> bool {
    if (ps_check_string(self)) {
        ps_advance(self);
        return true;
    }
    return false;
}

func ps_expect(self: ParserState*, kind_ord: int, code: string, msg: string) -> Token? {
    if (!ps_check(self, kind_ord)) {
        let got = token_to_string(ps_peek(self));
        ps_set_error(self, code, concat3_s(msg, ", got ", concat_s(got, " instead")), ps_peek(self));
        return null;
    }
    return ps_advance(self);
}

func ps_expect_ident(self: ParserState*, code: string, msg: string) -> Token? {
    if (!ps_check_ident(self)) {
        let got = token_to_string(ps_peek(self));
        ps_set_error(self, code, concat3_s(msg, ", got ", concat_s(got, " instead")), ps_peek(self));
        return null;
    }
    return ps_advance(self);
}

func token_ident_text(tok: Token) -> string? {
    match (tok.token_type) {
        TT_IDENT(t) => { return t; }
        _ => { return null; }
    }
}

func token_int_text(tok: Token) -> string? {
    match (tok.token_type) {
        TT_INT(t, v) => { return t; }
        _ => { return null; }
    }
}

func token_int_value(tok: Token) -> int? {
    match (tok.token_type) {
        TT_INT(t, v) => { return v; }
        _ => { return null; }
    }
}

func token_byte_text(tok: Token) -> string? {
    match (tok.token_type) {
        TT_BYTE(t, v) => { return t; }
        _ => { return null; }
    }
}

func token_string_text(tok: Token) -> string? {
    match (tok.token_type) {
        TT_STRING(t, v) => { return t; }
        _ => { return null; }
    }
}

func token_text_for_width(tok: Token) -> string {
    match (tok.token_type) {
        TT_IDENT(t) => { return t; }
        TT_INT(t, v) => { return t; }
        TT_BYTE(t, v) => { return t; }
        TT_STRING(t, v) => { return t; }
        TT_EOF => { return ""; }
        _ => { return token_to_string(tok); }
    }
}

func token_width(tok: Token) -> int {
    return len_s(token_text_for_width(tok));
}

func ps_span_start(self: ParserState*) -> Span {
    let here = ps_peek(self);
    return Span(here.line, here.column, here.line, here.column);
}

func ps_extend_span(self: ParserState*, start: Span) -> Span {
    let here = ps_last(self);
    return Span(
        start.start_line,
        start.start_column,
        here.line,
        here.column + token_width(here)
    );
}

func ps_expect_variable_name(self: ParserState*, code: string, msg: string) -> Token? {
    let tok = ps_peek(self);
    if (tok_is_future_extension(tok)) {
        let t = token_to_string(tok);
        ps_set_error(self, "PAR-0010", concat3_s("invalid variable name '", t, "': reserved keyword"), tok);
        return null;
    }
    let got = ps_expect_ident(self, code, msg)?;
    if (is_reserved_keyword(got)) {
        let ident = token_ident_text(got) as string;
        ps_set_error(self, "PAR-0011", concat3_s("invalid variable name '", ident, "': reserved identifier"), got);
        return null;
    }
    return got;
}

/* ------------------------------------
   Name helpers
   ------------------------------------ */

func parse_dotted_name_rest(self: ParserState*, first: string) -> string? {
    let name = first;
    while (ps_match(self, ord(TT_DOT))) {
        let ident = ps_expect_ident(self, "PAR-0300", "[PAR-0300] expected identifier after '.' in module name")?;
        let ident_text = token_ident_text(ident) as string;
        name = concat3_s(name, ".", ident_text);
    }
    return name;
}

struct QualifiedNameResult {
    module_path: VectorString*;
    name_qualifier: VectorString*?;
    name_tok: Token;
}

func qn_result_free_only_container(self: QualifiedNameResult*) {
    drop self;
}

func qn_result_free_all(self: QualifiedNameResult*) {
    vs_free(self.module_path);
    if (self.name_qualifier != null) {
        vs_free(self.name_qualifier as VectorString*);
    }
    drop self;
}

func ps_try_parse_qualified_name(self: ParserState*) -> QualifiedNameResult*? {
    if (!ps_check_ident(self)) {
        return null;
    }

    // Lookahead without building strings: parse only if we truly have ModulePath::Name.
    let i = self.index;
    let n = tv_len(self.tokens);

    let look = i + 1; // after first identifier
    while (look < n && tok_is(tv_get(self.tokens, look), ord(TT_DOT))) {
        look = look + 1;
        if (look >= n || !tok_is_ident(tv_get(self.tokens, look))) {
            return null;
        }
        look = look + 1;
    }

    if (look >= n || !tok_is(tv_get(self.tokens, look), ord(TT_DOUBLE_COLON))) {
        return null;
    }

    // Commit parse and build vectors.
    let first = ps_expect_ident(self, "PAR-0401", "[PAR-0401] expected identifier before '::'")?;

    with (let parts: VectorString*? = vs_create(4) => _free_vs_opt(parts),
          let qualifier: VectorString*? = null => _free_vs_opt(qualifier)) {
        vs_push(parts as VectorString*, token_ident_text(first) as string);

        while (ps_match(self, ord(TT_DOT))) {
            let part = ps_expect_ident(self, "PAR-0300", "[PAR-0300] expected identifier after '.' in module name")?;
            vs_push(parts as VectorString*, token_ident_text(part) as string);
        }

        ps_expect(self, ord(TT_DOUBLE_COLON), "PAR-0401", "[PAR-0401] expected '::' in qualified name")?;
        let name_tok = ps_expect_ident(self, "PAR-0401", "[PAR-0401] expected identifier after '::'")?;

        let current_name_tok = name_tok;

        while (ps_match(self, ord(TT_DOUBLE_COLON))) {
            if (qualifier == null) {
                qualifier = vs_create(2);
            }
            vs_push(qualifier as VectorString*, token_ident_text(current_name_tok) as string);
            current_name_tok = ps_expect_ident(self, "PAR-0401", "[PAR-0401] expected identifier after '::'")?;
        }

        let result = new QualifiedNameResult(parts as VectorString*, qualifier, current_name_tok);
        parts = null;
        qualifier = null;
        return result;
    }
}

/* ------------------------------------
   Type parsing
   ------------------------------------ */

func ps_parse_type(self: ParserState*) -> TypeRef*? {
    let start = ps_span_start(self);

    let module_path: VectorString*? = null;
    let name_qualifier: VectorString*? = null;
    let name_tok = Token(TT_EOF, 0, 0, 0);

    let qualified = ps_try_parse_qualified_name(self);
    if (qualified != null) {
        let q = qualified as QualifiedNameResult*;
        module_path = q.module_path;
        name_qualifier = q.name_qualifier;
        name_tok = q.name_tok;
        qn_result_free_only_container(q);
    } else {
        name_tok = ps_expect_ident(self, "PAR-0400", "[PAR-0400] expected type name")?;
    }

    let pointer_depth = 0;
    while (ps_match(self, ord(TT_STAR))) {
        pointer_depth = pointer_depth + 1;
    }

    let is_nullable = false;
    if (ps_match(self, ord(TT_QUESTION))) {
        is_nullable = true;
    }

    if (ps_check(self, ord(TT_LBRACKET))) {
        ps_set_error(self, "PAR-9401", "[PAR-9401] array types not yet supported: use pointers and [] indexing in expressions", ps_peek(self));
        if (module_path != null) {
            vs_free(module_path as VectorString*);
        }
        if (name_qualifier != null) {
            vs_free(name_qualifier as VectorString*);
        }
        return null;
    }

    let type_name = token_ident_text(name_tok) as string;
    return new TypeRef(type_name, pointer_depth, is_nullable, module_path, name_qualifier, ps_extend_span(self, start));
}

/* ------------------------------------
   Expression parsing
   ------------------------------------ */

func ps_is_builtin_type_name(self: ParserState*) -> bool {
    if (!ps_check_ident(self)) {
        return false;
    }
    let t = token_ident_text(ps_peek(self)) as string;
    return eq_s(t, "int") || eq_s(t, "byte") || eq_s(t, "bool") || eq_s(t, "string") || eq_s(t, "void");
}

func ps_is_unambiguous_type_start(self: ParserState*) -> bool {
    if (ps_is_builtin_type_name(self)) {
        return true;
    }

    if (!ps_check_ident(self)) {
        return false;
    }

    let saved = self.index;
    ps_advance(self); // identifier

    let has_suffix = false;
    while (ps_check(self, ord(TT_STAR)) || ps_check(self, ord(TT_QUESTION))) {
        has_suffix = true;
        ps_advance(self);
    }

    let at_boundary = ps_check(self, ord(TT_RPAREN)) || ps_check(self, ord(TT_COMMA));

    self.index = saved;
    return has_suffix && at_boundary;
}

func ps_parse_call_argument(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    if (ps_is_unambiguous_type_start(self)) {
        let type_ref = ps_parse_type(self)?;
        let node = expr_node_create(EX_TYPE, ps_extend_span(self, start));
        node.type_ref = type_ref;
        return expr_arena_add(self.expr_arena, node);
    }
    return ps_parse_expr(self);
}

func ps_check_reserved_binary_op(self: ParserState*) -> Unit? {
    let tok = ps_peek(self);
    if (tok_is(tok, ord(TT_AMP))) {
        ps_set_error(self, "PAR-0226", "[PAR-0226] '&' (bitwise AND) operator is not yet supported", tok);
        return null;
    }
    if (tok_is(tok, ord(TT_PIPE))) {
        ps_set_error(self, "PAR-0226", "[PAR-0226] '|' (bitwise OR) operator is not yet supported", tok);
        return null;
    }
    if (tok_is(tok, ord(TT_CARET))) {
        ps_set_error(self, "PAR-0226", "[PAR-0226] '^' (bitwise XOR) operator is not yet supported", tok);
        return null;
    }
    if (tok_is(tok, ord(TT_LSHIFT))) {
        ps_set_error(self, "PAR-0226", "[PAR-0226] '<<' (left shift) operator is not yet supported", tok);
        return null;
    }
    if (tok_is(tok, ord(TT_RSHIFT))) {
        ps_set_error(self, "PAR-0226", "[PAR-0226] '>>' (right shift) operator is not yet supported", tok);
        return null;
    }
    return present();
}

func ps_parse_expr(self: ParserState*) -> ExprId? {
    return ps_parse_or_expr(self);
}

func ps_parse_or_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_and_expr(self)?;
    ps_check_reserved_binary_op(self)?;

    let current = expr;
    while (ps_match(self, ord(TT_OROR))) {
        let op_tok = ps_last(self);
        let right = ps_parse_and_expr(self)?;
        ps_check_reserved_binary_op(self)?;

        let node = expr_node_create(EX_BINARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = current;
        node.expr_b = right;
        current = expr_arena_add(self.expr_arena, node);
    }
    return current;
}

func ps_parse_and_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_equality_expr(self)?;
    ps_check_reserved_binary_op(self)?;

    let current = expr;
    while (ps_match(self, ord(TT_ANDAND))) {
        let op_tok = ps_last(self);
        let right = ps_parse_equality_expr(self)?;
        ps_check_reserved_binary_op(self)?;

        let node = expr_node_create(EX_BINARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = current;
        node.expr_b = right;
        current = expr_arena_add(self.expr_arena, node);
    }
    return current;
}

func ps_parse_equality_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_rel_expr(self)?;

    let current = expr;
    while (ps_match_any2(self, ord(TT_EQEQ), ord(TT_NE))) {
        let op_tok = ps_last(self);
        let right = ps_parse_rel_expr(self)?;

        let node = expr_node_create(EX_BINARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = current;
        node.expr_b = right;
        current = expr_arena_add(self.expr_arena, node);
    }
    return current;
}

func ps_parse_rel_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_add_expr(self)?;

    let current = expr;
    while (ps_match_any4(self, ord(TT_LT), ord(TT_GT), ord(TT_LE), ord(TT_GE))) {
        let op_tok = ps_last(self);
        let right = ps_parse_add_expr(self)?;

        let node = expr_node_create(EX_BINARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = current;
        node.expr_b = right;
        current = expr_arena_add(self.expr_arena, node);
    }
    return current;
}

func ps_parse_add_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_mul_expr(self)?;

    let current = expr;
    while (ps_match_any2(self, ord(TT_PLUS), ord(TT_MINUS))) {
        let op_tok = ps_last(self);
        let right = ps_parse_mul_expr(self)?;

        let node = expr_node_create(EX_BINARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = current;
        node.expr_b = right;
        current = expr_arena_add(self.expr_arena, node);
    }
    return current;
}

func ps_parse_mul_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_unary_expr(self)?;

    let current = expr;
    while (ps_match_any3(self, ord(TT_STAR), ord(TT_SLASH), ord(TT_MODULO))) {
        let op_tok = ps_last(self);
        let right = ps_parse_unary_expr(self)?;

        let node = expr_node_create(EX_BINARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = current;
        node.expr_b = right;
        current = expr_arena_add(self.expr_arena, node);
    }
    return current;
}

func ps_parse_unary_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);

    if (ps_match(self, ord(TT_BANG))) {
        let op_tok = ps_last(self);
        let operand = ps_parse_unary_expr(self)?;

        let node = expr_node_create(EX_UNARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = operand;
        return expr_arena_add(self.expr_arena, node);
    }
    if (ps_match(self, ord(TT_MINUS))) {
        let op_tok = ps_last(self);
        let operand = ps_parse_unary_expr(self)?;

        let node = expr_node_create(EX_UNARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = operand;
        return expr_arena_add(self.expr_arena, node);
    }
    if (ps_match(self, ord(TT_STAR))) {
        let op_tok = ps_last(self);
        let operand = ps_parse_unary_expr(self)?;

        let node = expr_node_create(EX_UNARY, ps_extend_span(self, start));
        node.text_value = token_to_string(op_tok);
        node.expr_a = operand;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_check(self, ord(TT_TILDE))) {
        let tok = ps_peek(self);
        ps_set_error(self, "PAR-0226", "[PAR-0226] '~' (bitwise NOT) operator is not yet supported", tok);
        return null;
    }

    return ps_parse_cast_expr(self);
}

func ps_parse_cast_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let expr = ps_parse_postfix_expr(self)?;
    if (ps_match(self, ord(TT_AS))) {
        let target_type = ps_parse_type(self)?;
        let node = expr_node_create(EX_CAST, ps_extend_span(self, start));
        node.expr_a = expr;
        node.type_ref = target_type;
        return expr_arena_add(self.expr_arena, node);
    }
    return expr;
}

func ps_parse_postfix_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let primary = ps_parse_primary_expr(self)?;
    let current = primary;

    while (true) {
        if (ps_match(self, ord(TT_LPAREN))) {
            with (let args: VectorBase*? = id_vec_create(4) => _free_id_vec_opt(args)) {
                if (!ps_check(self, ord(TT_RPAREN))) {
                    while (true) {
                        let arg = ps_parse_call_argument(self)?;
                        id_vec_push(args as VectorBase*, arg);
                        if (!ps_match(self, ord(TT_COMMA))) {
                            break;
                        }
                    }
                }
                ps_expect(self, ord(TT_RPAREN), "PAR-0210", "[PAR-0210] expected ')' after arguments")?;

                let node = expr_node_create(EX_CALL, ps_extend_span(self, start));
                node.expr_a = current;
                node.ids = args as VectorBase*;
                args = null;
                current = expr_arena_add(self.expr_arena, node);
                continue;
            }
        }

        if (ps_match(self, ord(TT_LBRACKET))) {
            let index = ps_parse_expr(self)?;
            ps_expect(self, ord(TT_RBRACKET), "PAR-0211", "[PAR-0211] expected ']' after index")?;

            let node = expr_node_create(EX_INDEX, ps_extend_span(self, start));
            node.expr_a = current;
            node.expr_b = index;
            current = expr_arena_add(self.expr_arena, node);
            continue;
        }

        if (ps_match(self, ord(TT_DOT))) {
            let field_tok = ps_expect_ident(self, "PAR-0212", "[PAR-0212] expected field name after '.'")?;

            let node = expr_node_create(EX_FIELD, ps_extend_span(self, start));
            node.expr_a = current;
            node.text_value = token_ident_text(field_tok) as string;
            current = expr_arena_add(self.expr_arena, node);
            continue;
        }

        if (ps_match(self, ord(TT_QUESTION))) {
            let node = expr_node_create(EX_TRY, ps_extend_span(self, start));
            node.expr_a = current;
            current = expr_arena_add(self.expr_arena, node);
            continue;
        }

        break;
    }

    return current;
}

func ps_parse_primary_expr(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);
    let tok = ps_peek(self);

    if (ps_match(self, ord(TT_NEW))) {
        let parsed_type = ps_parse_type(self)?;
        with (let type_ref: TypeRef*? = parsed_type => _free_type_ref_opt(type_ref),
              let args: VectorBase*? = null => _free_id_vec_opt(args)) {
            if (ps_match(self, ord(TT_LPAREN))) {
                args = id_vec_create(4);
                if (!ps_check(self, ord(TT_RPAREN))) {
                    while (true) {
                        let arg = ps_parse_call_argument(self)?;
                        id_vec_push(args as VectorBase*, arg);
                        if (!ps_match(self, ord(TT_COMMA))) {
                            break;
                        }
                    }
                }
                ps_expect(self, ord(TT_RPAREN), "PAR-0223", "[PAR-0223] expected ')' after arguments to 'new'")?;
            }

            let node = expr_node_create(EX_NEW, ps_extend_span(self, start));
            node.type_ref = type_ref as TypeRef*;
            if (args == null) {
                node.ids = id_vec_create(0);
            } else {
                node.ids = args as VectorBase*;
            }
            type_ref = null;
            args = null;
            return expr_arena_add(self.expr_arena, node);
        }
    }

    if (ps_match_int(self)) {
        let node = expr_node_create(EX_INT, ps_extend_span(self, start));
        node.int_value = token_int_value(tok) as int;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match_byte(self)) {
        let node = expr_node_create(EX_BYTE, ps_extend_span(self, start));
        node.text_value = token_byte_text(tok) as string;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match_string(self)) {
        let node = expr_node_create(EX_STRING, ps_extend_span(self, start));
        node.text_value = token_string_text(tok) as string;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match(self, ord(TT_TRUE))) {
        let node = expr_node_create(EX_BOOL, ps_extend_span(self, start));
        node.bool_value = true;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match(self, ord(TT_FALSE))) {
        let node = expr_node_create(EX_BOOL, ps_extend_span(self, start));
        node.bool_value = false;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match(self, ord(TT_NULL))) {
        let node = expr_node_create(EX_NULL, ps_extend_span(self, start));
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_check_ident(self)) {
        let qualified = ps_try_parse_qualified_name(self);
        if (qualified != null) {
            let q = qualified as QualifiedNameResult*;
            let node = expr_node_create(EX_VAR_REF, ps_extend_span(self, start));
            node.text_value = token_ident_text(q.name_tok) as string;
            node.module_path = q.module_path;
            node.name_qualifier = q.name_qualifier;
            qn_result_free_only_container(q);
            return expr_arena_add(self.expr_arena, node);
        }

        let name_tok = ps_advance(self);
        let node = expr_node_create(EX_VAR_REF, ps_extend_span(self, start));
        node.text_value = token_ident_text(name_tok) as string;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match(self, ord(TT_LPAREN))) {
        let inner = ps_parse_expr(self)?;
        ps_expect(self, ord(TT_RPAREN), "PAR-0224", "[PAR-0224] expected ')' after expression")?;
        let node = expr_node_create(EX_PAREN, ps_extend_span(self, start));
        node.expr_a = inner;
        return expr_arena_add(self.expr_arena, node);
    }

    ps_set_error(self, "PAR-0225", concat3_s("[PAR-0225] unexpected token in expression: ", token_to_string(tok), ""), tok);
    return null;
}

/* ------------------------------------
   Pattern parsing
   ------------------------------------ */

func ps_parse_pattern(self: ParserState*) -> PatternId? {
    let start = ps_span_start(self);

    if (ps_match(self, ord(TT_UNDERSCORE))) {
        let node = pattern_node_create(PT_WILDCARD, ps_extend_span(self, start));
        return pattern_arena_add(self.pattern_arena, node);
    }

    if (ps_check_ident(self)) {
        let module_path: VectorString*? = null;
        let name_qualifier: VectorString*? = null;
        let name_tok = Token(TT_EOF, 0, 0, 0);

        let qualified = ps_try_parse_qualified_name(self);
        if (qualified != null) {
            let q = qualified as QualifiedNameResult*;
            module_path = q.module_path;
            name_qualifier = q.name_qualifier;
            name_tok = q.name_tok;
            qn_result_free_only_container(q);
        } else {
            name_tok = ps_advance(self);
        }

        let node = pattern_node_create(PT_VARIANT, ps_extend_span(self, start));
        node.name = token_ident_text(name_tok) as string;
        node.module_path = module_path;
        node.name_qualifier = name_qualifier;

        if (ps_match(self, ord(TT_LPAREN))) {
            with (let vars: VectorString*? = vs_create(2) => _free_vs_opt(vars)) {
                if (!ps_check(self, ord(TT_RPAREN))) {
                    while (true) {
                        let var_tok = ps_expect_variable_name(self, "PAR-0180", "[PAR-0180] expected pattern variable name")?;
                        vs_push(vars as VectorString*, token_ident_text(var_tok) as string);
                        if (!ps_match(self, ord(TT_COMMA))) {
                            break;
                        }
                    }
                }
                ps_expect(self, ord(TT_RPAREN), "PAR-0181", "[PAR-0181] expected ')' in pattern")?;
                node.vars = vars;
                vars = null;
            }
        }

        // refresh span after optional payload
        node.span = ps_extend_span(self, start);
        return pattern_arena_add(self.pattern_arena, node);
    }

    ps_set_error(self, "PAR-0182", concat3_s("[PAR-0182] unexpected token in pattern: ", token_to_string(ps_peek(self)), ""), ps_peek(self));
    return null;
}

/* ------------------------------------
   Statement parsing
   ------------------------------------ */

func ps_parse_block(self: ParserState*) -> StmtId? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_LBRACE), "PAR-0090", "[PAR-0090] expected '{' to start block")?;

    with (let stmts: VectorBase*? = id_vec_create(8) => _free_id_vec_opt(stmts)) {
        while (!ps_check(self, ord(TT_RBRACE))) {
            let stmt = ps_parse_stmt(self)?;
            id_vec_push(stmts as VectorBase*, stmt);
        }

        ps_expect(self, ord(TT_RBRACE), "PAR-0091", "[PAR-0091] expected '}' after block")?;

        let node = stmt_node_create(ST_BLOCK, ps_extend_span(self, start));
        node.ids = stmts as VectorBase*;
        stmts = null;
        return stmt_arena_add(self.stmt_arena, node);
    }
}

func ps_parse_break_stmt(self: ParserState*) -> StmtId? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_BREAK), "PAR-0190", "[PAR-0190] expected 'break'")?;
    let node = stmt_node_create(ST_BREAK, ps_extend_span(self, start));
    return stmt_arena_add(self.stmt_arena, node);
}

func ps_parse_continue_stmt(self: ParserState*) -> StmtId? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_CONTINUE), "PAR-0200", "[PAR-0200] expected 'continue'")?;
    let node = stmt_node_create(ST_CONTINUE, ps_extend_span(self, start));
    return stmt_arena_add(self.stmt_arena, node);
}

func ps_parse_return_stmt(self: ParserState*) -> StmtId? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_RETURN), "PAR-0150", "[PAR-0150] expected 'return'")?;

    let node = stmt_node_create(ST_RETURN, ps_extend_span(self, start));
    if (!ps_check(self, ord(TT_SEMI))) {
        node.expr_a = ps_parse_expr(self)?;
        node.span = ps_extend_span(self, start);
    }
    return stmt_arena_add(self.stmt_arena, node);
}

func ps_parse_drop_stmt(self: ParserState*) -> StmtId? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_DROP), "PAR-0160", "[PAR-0160] expected 'drop'")?;
    let name_tok = ps_expect_variable_name(self, "PAR-0161", "[PAR-0161] expected variable name after 'drop'")?;

    let node = stmt_node_create(ST_DROP, ps_extend_span(self, start));
    node.name = token_ident_text(name_tok) as string;
    return stmt_arena_add(self.stmt_arena, node);
}

func ps_parse_let_stmt(self: ParserState*) -> StmtId? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_LET), "PAR-0110", "[PAR-0110] expected 'let'")?;
    let name_tok = ps_expect_variable_name(self, "PAR-0111", "[PAR-0111] expected variable name")?;

    with (let type_ref: TypeRef*? = null => _free_type_ref_opt(type_ref)) {
        if (ps_match(self, ord(TT_COLON))) {
            type_ref = ps_parse_type(self)?;
        }

        ps_expect(self, ord(TT_EQ), "PAR-0112", "[PAR-0112] expected '=' in let binding")?;
        let value = ps_parse_expr(self)?;

        let node = stmt_node_create(ST_LET, ps_extend_span(self, start));
        node.name = token_ident_text(name_tok) as string;
        node.type_ref = type_ref;
        type_ref = null;
        node.expr_a = value;
        return stmt_arena_add(self.stmt_arena, node);
    }
}

func ps_parse_if_stmt(self: ParserState*) -> StmtId? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_IF), "PAR-0120", "[PAR-0120] expected 'if'")?;
    ps_expect(self, ord(TT_LPAREN), "PAR-0121", "[PAR-0121] expected '(' after 'if'")?;
    let cond = ps_parse_expr(self)?;
    ps_expect(self, ord(TT_RPAREN), "PAR-0122", "[PAR-0122] expected ')' after condition")?;

    let then_stmt = ps_parse_stmt(self)?;

    let else_stmt = invalid_stmt_id();
    if (ps_match(self, ord(TT_ELSE))) {
        let e = ps_parse_stmt(self)?;
        let node = stmt_node_create(ST_IF, ps_extend_span(self, start));
        node.expr_a = cond;
        node.stmt_a = then_stmt;
        node.stmt_b = e;
        return stmt_arena_add(self.stmt_arena, node);
    }

    let node = stmt_node_create(ST_IF, ps_extend_span(self, start));
    node.expr_a = cond;
    node.stmt_a = then_stmt;
    node.stmt_b = else_stmt;
    return stmt_arena_add(self.stmt_arena, node);
}

func ps_parse_while_stmt(self: ParserState*) -> StmtId? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_WHILE), "PAR-0130", "[PAR-0130] expected 'while'")?;
    ps_expect(self, ord(TT_LPAREN), "PAR-0131", "[PAR-0131] expected '('")?;
    let cond = ps_parse_expr(self)?;
    ps_expect(self, ord(TT_RPAREN), "PAR-0132", "[PAR-0132] expected ')'")?;

    let body = ps_parse_block(self)?;

    let node = stmt_node_create(ST_WHILE, ps_extend_span(self, start));
    node.expr_a = cond;
    node.stmt_a = body;
    return stmt_arena_add(self.stmt_arena, node);
}

func ps_parse_for_stmt(self: ParserState*) -> StmtId? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_FOR), "PAR-0140", "[PAR-0140] expected 'for'")?;
    ps_expect(self, ord(TT_LPAREN), "PAR-0141", "[PAR-0141] expected '(' after 'for'")?;

    let init = invalid_stmt_id();
    if (!ps_check(self, ord(TT_SEMI))) {
        let i = ps_parse_simple_stmt(self)?;
        ps_expect(self, ord(TT_SEMI), "PAR-0142", "[PAR-0142] expected ';' after for loop initialization")?;
        let cond = invalid_expr_id();
        let post = invalid_stmt_id();

        let cond_value = cond;
        if (!ps_check(self, ord(TT_SEMI))) {
            let c = ps_parse_expr(self)?;
            ps_expect(self, ord(TT_SEMI), "PAR-0143", "[PAR-0143] expected ';' after for loop condition")?;
            let post_value = post;
            if (!ps_check(self, ord(TT_RPAREN))) {
                post_value = ps_parse_simple_stmt(self)?;
            }
            ps_expect(self, ord(TT_RPAREN), "PAR-0144", "[PAR-0144] expected ')' after for loop clauses")?;
            let body = ps_parse_block(self)?;

            let node = stmt_node_create(ST_FOR, ps_extend_span(self, start));
            node.stmt_a = i;
            node.expr_a = c;
            node.stmt_b = post_value;
            node.stmt_c = body;
            return stmt_arena_add(self.stmt_arena, node);
        }

        ps_expect(self, ord(TT_SEMI), "PAR-0143", "[PAR-0143] expected ';' after for loop condition")?;
        let post_value2 = post;
        if (!ps_check(self, ord(TT_RPAREN))) {
            post_value2 = ps_parse_simple_stmt(self)?;
        }
        ps_expect(self, ord(TT_RPAREN), "PAR-0144", "[PAR-0144] expected ')' after for loop clauses")?;
        let body2 = ps_parse_block(self)?;

        let node2 = stmt_node_create(ST_FOR, ps_extend_span(self, start));
        node2.stmt_a = i;
        node2.expr_a = cond_value;
        node2.stmt_b = post_value2;
        node2.stmt_c = body2;
        return stmt_arena_add(self.stmt_arena, node2);
    }

    // empty init
    ps_advance(self); // ';'

    let cond3 = invalid_expr_id();
    if (!ps_check(self, ord(TT_SEMI))) {
        let c3 = ps_parse_expr(self)?;
        ps_expect(self, ord(TT_SEMI), "PAR-0143", "[PAR-0143] expected ';' after for loop condition")?;

        let post3 = invalid_stmt_id();
        if (!ps_check(self, ord(TT_RPAREN))) {
            post3 = ps_parse_simple_stmt(self)?;
        }
        ps_expect(self, ord(TT_RPAREN), "PAR-0144", "[PAR-0144] expected ')' after for loop clauses")?;
        let body3 = ps_parse_block(self)?;

        let node3 = stmt_node_create(ST_FOR, ps_extend_span(self, start));
        node3.stmt_a = init;
        node3.expr_a = c3;
        node3.stmt_b = post3;
        node3.stmt_c = body3;
        return stmt_arena_add(self.stmt_arena, node3);
    }

    ps_advance(self); // second ';'

    let post4 = invalid_stmt_id();
    if (!ps_check(self, ord(TT_RPAREN))) {
        post4 = ps_parse_simple_stmt(self)?;
    }

    ps_expect(self, ord(TT_RPAREN), "PAR-0144", "[PAR-0144] expected ')' after for loop clauses")?;
    let body4 = ps_parse_block(self)?;

    let node4 = stmt_node_create(ST_FOR, ps_extend_span(self, start));
    node4.stmt_a = init;
    node4.expr_a = cond3;
    node4.stmt_b = post4;
    node4.stmt_c = body4;
    return stmt_arena_add(self.stmt_arena, node4);
}

func ps_parse_match_stmt(self: ParserState*) -> StmtId? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_MATCH), "PAR-0170", "[PAR-0170] expected 'match'")?;
    ps_expect(self, ord(TT_LPAREN), "PAR-0171", "[PAR-0171] expected '('")?;
    let expr = ps_parse_expr(self)?;
    ps_expect(self, ord(TT_RPAREN), "PAR-0172", "[PAR-0172] expected ')'")?;
    ps_expect(self, ord(TT_LBRACE), "PAR-0173", "[PAR-0173] expected '{' after match expression")?;

    with (let arms: VectorBase*? = ptr_vec_create(4) => _free_match_arm_vec_opt(arms)) {
        while (!ps_check(self, ord(TT_RBRACE))) {
            let arm_start = ps_span_start(self);
            let pattern = ps_parse_pattern(self)?;
            ps_expect(self, ord(TT_ARROW_MATCH), "PAR-0174", "[PAR-0174] expected '=>' in match arm")?;
            let body = ps_parse_block(self)?;
            let arm = new MatchArm(pattern, body, ps_extend_span(self, arm_start));
            ptr_vec_push(arms as VectorBase*, arm as void*);
        }

        ps_expect(self, ord(TT_RBRACE), "PAR-0175", "[PAR-0175] expected '}' after match")?;

        if (vec_size(arms as VectorBase*) == 0) {
            ps_set_error(self, "PAR-0177", "[PAR-0177] match statement must have at least one arm", ps_peek(self));
            return null;
        }

        // duplicate wildcard/variant pattern check
        for (let i = 0; i < vec_size(arms as VectorBase*); i = i + 1) {
            let ai = ptr_vec_get(arms as VectorBase*, i) as MatchArm*;
            let pi = pattern_arena_get(self.pattern_arena, ai.pattern);

            for (let j = i + 1; j < vec_size(arms as VectorBase*); j = j + 1) {
                let aj = ptr_vec_get(arms as VectorBase*, j) as MatchArm*;
                let pj = pattern_arena_get(self.pattern_arena, aj.pattern);

                if (ord(pi.kind) == ord(PT_WILDCARD) && ord(pj.kind) == ord(PT_WILDCARD)) {
                    ps_set_error(self, "PAR-0176", "[PAR-0176] duplicate variant patterns in match statement", ps_peek(self));
                    return null;
                }

                if (ord(pi.kind) == ord(PT_VARIANT) && ord(pj.kind) == ord(PT_VARIANT) && eq_s(pi.name, pj.name)) {
                    ps_set_error(self, "PAR-0176", "[PAR-0176] duplicate variant patterns in match statement", ps_peek(self));
                    return null;
                }
            }
        }

        let node = stmt_node_create(ST_MATCH, ps_extend_span(self, start));
        node.expr_a = expr;
        node.match_arms = arms as VectorBase*;
        arms = null;
        return stmt_arena_add(self.stmt_arena, node);
    }
}

func ps_parse_with_item(self: ParserState*) -> WithItem*? {
    let start = ps_span_start(self);
    let init = ps_parse_simple_stmt(self)?;

    let cleanup_stmt = invalid_stmt_id();
    let has_cleanup = false;

    if (ps_match(self, ord(TT_ARROW_MATCH))) {
        cleanup_stmt = ps_parse_simple_stmt(self)?;
        has_cleanup = true;
    }

    return new WithItem(init, cleanup_stmt, has_cleanup, ps_extend_span(self, start));
}

func ps_parse_with_stmt(self: ParserState*) -> StmtId? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_WITH), "PAR-0500", "[PAR-0500] expected 'with'")?;
    ps_expect(self, ord(TT_LPAREN), "PAR-0501", "[PAR-0501] expected '(' after 'with'")?;

    with (let items: VectorBase*? = ptr_vec_create(4) => _free_with_item_vec_opt(items)) {
        while (true) {
            let item = ps_parse_with_item(self)?;
            ptr_vec_push(items as VectorBase*, item as void*);
            if (!ps_match(self, ord(TT_COMMA))) {
                break;
            }
        }

        ps_expect(self, ord(TT_RPAREN), "PAR-0502", "[PAR-0502] expected ')' after with items")?;

        let body = ps_parse_block(self)?;

        let cleanup_body = invalid_stmt_id();
        let has_cleanup_body = false;
        if (ps_match(self, ord(TT_CLEANUP))) {
            cleanup_body = ps_parse_block(self)?;
            has_cleanup_body = true;
        }

        let has_arrows = false;
        let has_bare = false;
        for (let i = 0; i < vec_size(items as VectorBase*); i = i + 1) {
            let it = ptr_vec_get(items as VectorBase*, i) as WithItem*;
            if (it.has_cleanup) {
                has_arrows = true;
            } else {
                has_bare = true;
            }
        }

        if (has_arrows && has_bare) {
            ps_set_error(self, "PAR-0503", "[PAR-0503] 'with': all items must use '=>' or none", ps_peek(self));
            return null;
        }

        if (has_arrows && has_cleanup_body) {
            ps_set_error(self, "PAR-0504", "[PAR-0504] 'with': cannot have both '=>' and cleanup block", ps_peek(self));
            return null;
        }

        if (!has_arrows && !has_cleanup_body) {
            ps_set_error(self, "PAR-0505", "[PAR-0505] 'with': cleanup block required when '=>' is not used", ps_peek(self));
            return null;
        }

        let node = stmt_node_create(ST_WITH, ps_extend_span(self, start));
        node.with_items = items as VectorBase*;
        node.stmt_a = body;
        if (has_cleanup_body) {
            node.stmt_b = cleanup_body;
        }
        items = null;
        return stmt_arena_add(self.stmt_arena, node);
    }
}

func ps_parse_case_literal(self: ParserState*) -> ExprId? {
    let start = ps_span_start(self);

    let tok = ps_peek(self);
    if (ps_match_int(self)) {
        let node = expr_node_create(EX_INT, ps_extend_span(self, start));
        node.int_value = token_int_value(tok) as int;
        node.text_value = token_int_text(tok) as string;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match_byte(self)) {
        let node = expr_node_create(EX_BYTE, ps_extend_span(self, start));
        node.text_value = token_byte_text(tok) as string;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match_string(self)) {
        let node = expr_node_create(EX_STRING, ps_extend_span(self, start));
        node.text_value = token_string_text(tok) as string;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match(self, ord(TT_TRUE))) {
        let node = expr_node_create(EX_BOOL, ps_extend_span(self, start));
        node.bool_value = true;
        return expr_arena_add(self.expr_arena, node);
    }

    if (ps_match(self, ord(TT_FALSE))) {
        let node = expr_node_create(EX_BOOL, ps_extend_span(self, start));
        node.bool_value = false;
        return expr_arena_add(self.expr_arena, node);
    }

    ps_set_error(self, "PAR-0241", "[PAR-0241] expected literal in 'case' arm", tok);
    return null;
}

func ps_parse_case_stmt(self: ParserState*) -> StmtId? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_CASE), "PAR-0230", "[PAR-0230] expected 'case'")?;
    ps_expect(self, ord(TT_LPAREN), "PAR-0231", "[PAR-0231] expected '('")?;
    let expr = ps_parse_expr(self)?;
    ps_expect(self, ord(TT_RPAREN), "PAR-0232", "[PAR-0232] expected ')'")?;
    ps_expect(self, ord(TT_LBRACE), "PAR-0233", "[PAR-0233] expected '{' after 'case' expression")?;

    with (let arms: VectorBase*? = ptr_vec_create(4) => _free_case_arm_vec_opt(arms),
          let else_arm: CaseElse*? = null => _free_case_else_opt(else_arm)) {
        let seen_else = false;

        while (!ps_check(self, ord(TT_RBRACE))) {
            if (ps_match(self, ord(TT_ELSE))) {
                if (seen_else) {
                    ps_set_error(self, "PAR-0236", "[PAR-0236] duplicate 'else' arm in 'case' statement", ps_peek(self));
                    return null;
                }

                let else_start = ps_span_start(self);
                if (ps_match(self, ord(TT_ARROW_MATCH))) {
                    ps_set_error(self, "PAR-0237", "[PAR-0237] '=>' not allowed in 'else' arm", ps_peek(self));
                    return null;
                }

                let body = ps_parse_stmt(self)?;
                else_arm = new CaseElse(body, ps_extend_span(self, else_start));
                seen_else = true;
                continue;
            }

            if (seen_else) {
                ps_set_error(self, "PAR-0234", "[PAR-0234] value arm cannot appear after 'else' in 'case' statement", ps_peek(self));
                return null;
            }

            let arm_start = ps_span_start(self);
            let literal = ps_parse_case_literal(self)?;
            ps_expect(self, ord(TT_ARROW_MATCH), "PAR-0235", "[PAR-0235] expected '=>' in 'case' arm")?;
            let body = ps_parse_stmt(self)?;
            let arm = new CaseArm(literal, body, ps_extend_span(self, arm_start));
            ptr_vec_push(arms as VectorBase*, arm as void*);
        }

        ps_expect(self, ord(TT_RBRACE), "PAR-0239", "[PAR-0239] expected '}' after 'case' statement")?;

        if (vec_size(arms as VectorBase*) == 0 && else_arm == null) {
            ps_set_error(self, "PAR-0240", "[PAR-0240] 'case' statement must have at least one arm", ps_peek(self));
            return null;
        }

        let node = stmt_node_create(ST_CASE, ps_extend_span(self, start));
        node.expr_a = expr;
        node.case_arms = arms as VectorBase*;
        node.case_else = else_arm;
        arms = null;
        else_arm = null;
        return stmt_arena_add(self.stmt_arena, node);
    }
}

func ps_parse_simple_stmt(self: ParserState*) -> StmtId? {
    let start = ps_span_start(self);

    if (ps_check(self, ord(TT_LET))) {
        return ps_parse_let_stmt(self);
    }
    if (ps_check(self, ord(TT_BREAK))) {
        return ps_parse_break_stmt(self);
    }
    if (ps_check(self, ord(TT_CONTINUE))) {
        return ps_parse_continue_stmt(self);
    }
    if (ps_check(self, ord(TT_RETURN))) {
        return ps_parse_return_stmt(self);
    }
    if (ps_check(self, ord(TT_DROP))) {
        return ps_parse_drop_stmt(self);
    }

    let expr = ps_parse_expr(self)?;
    if (ps_match(self, ord(TT_EQ))) {
        let value = ps_parse_expr(self)?;
        let node = stmt_node_create(ST_ASSIGN, ps_extend_span(self, start));
        node.expr_a = expr;
        node.expr_b = value;
        return stmt_arena_add(self.stmt_arena, node);
    }

    let node = stmt_node_create(ST_EXPR, ps_extend_span(self, start));
    node.expr_a = expr;
    return stmt_arena_add(self.stmt_arena, node);
}

func ps_parse_stmt(self: ParserState*) -> StmtId? {
    if (ps_check(self, ord(TT_LBRACE))) {
        return ps_parse_block(self);
    }
    if (ps_check(self, ord(TT_IF))) {
        return ps_parse_if_stmt(self);
    }
    if (ps_check(self, ord(TT_MATCH))) {
        return ps_parse_match_stmt(self);
    }
    if (ps_check(self, ord(TT_CASE))) {
        return ps_parse_case_stmt(self);
    }
    if (ps_check(self, ord(TT_WHILE))) {
        return ps_parse_while_stmt(self);
    }
    if (ps_check(self, ord(TT_FOR))) {
        return ps_parse_for_stmt(self);
    }
    if (ps_check(self, ord(TT_WITH))) {
        return ps_parse_with_stmt(self);
    }

    let simple_stmt = ps_parse_simple_stmt(self)?;
    ps_expect(self, ord(TT_SEMI), "PAR-0100", "[PAR-0100] expected ';' after statement")?;
    return simple_stmt;
}

/* ------------------------------------
   Top-level declarations
   ------------------------------------ */

func ps_make_empty_block_stmt(self: ParserState*, span: Span) -> StmtId {
    let node = stmt_node_create(ST_BLOCK, span);
    node.ids = id_vec_create(0);
    return stmt_arena_add(self.stmt_arena, node);
}

func ps_finish_function(self: ParserState*, start: Span, name_tok: Token, params: VectorBase*, is_extern: bool, ret_type: TypeRef*) -> FuncDecl*? {
    let body = invalid_stmt_id();
    if (is_extern) {
        ps_expect(self, ord(TT_SEMI), "PAR-0046", "[PAR-0046] expected ';' after extern function decl")?;
        body = ps_make_empty_block_stmt(self, ps_extend_span(self, start));
    } else {
        body = ps_parse_block(self)?;
    }

    return new FuncDecl(
        token_ident_text(name_tok) as string,
        params,
        ret_type,
        body,
        is_extern,
        ps_extend_span(self, start)
    );
}

func ps_parse_function(self: ParserState*, is_extern: bool) -> FuncDecl*? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_FUNC), "PAR-0040", "[PAR-0040] expected 'func'")?;
    let name_tok = ps_expect_ident(self, "PAR-0041", "[PAR-0041] expected function name")?;
    ps_expect(self, ord(TT_LPAREN), "PAR-0042", "[PAR-0042] expected '('")?;

    with (let params: VectorBase*? = ptr_vec_create(4) => _free_param_vec_opt(params),
          let ret_type: TypeRef*? = null => _free_type_ref_opt(ret_type)) {
        if (!ps_check(self, ord(TT_RPAREN))) {
            while (true) {
                let param_name = ps_expect_ident(self, "PAR-0043", "[PAR-0043] expected parameter name")?;
                ps_expect(self, ord(TT_COLON), "PAR-0044", "[PAR-0044] expected ':' after parameter name")?;
                let param_type = ps_parse_type(self)?;
                let p = new Param(token_ident_text(param_name) as string, param_type);
                ptr_vec_push(params as VectorBase*, p as void*);
                if (!ps_match(self, ord(TT_COMMA))) {
                    break;
                }
            }
        }
        ps_expect(self, ord(TT_RPAREN), "PAR-0045", "[PAR-0045] expected ')' after parameters")?;

        if (ps_match(self, ord(TT_ARROW_FUNC))) {
            ret_type = ps_parse_type(self)?;
        } else {
            ret_type = new TypeRef("void", 0, false, null, null, ps_extend_span(self, start));
        }

        let result = ps_finish_function(self, start, name_tok, params as VectorBase*, is_extern, ret_type as TypeRef*);
        if (result != null) {
            params = null;
            ret_type = null;
        }
        return result;
    }
}

func ps_parse_extern_func(self: ParserState*) -> FuncDecl*? {
    ps_expect(self, ord(TT_EXTERN), "PAR-0030", "[PAR-0030] expected 'extern'")?;
    return ps_parse_function(self, true);
}

func ps_parse_struct(self: ParserState*) -> StructDecl*? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_STRUCT), "PAR-0050", "[PAR-0050] expected 'struct'")?;
    let name_tok = ps_expect_ident(self, "PAR-0051", "[PAR-0051] expected struct name")?;
    ps_expect(self, ord(TT_LBRACE), "PAR-0052", "[PAR-0052] expected '{' after struct name")?;

    with (let fields: VectorBase*? = ptr_vec_create(4) => _free_field_decl_vec_opt(fields)) {
        while (!ps_check(self, ord(TT_RBRACE))) {
            let field_name = ps_expect_ident(self, "PAR-0053", "[PAR-0053] expected field name")?;
            ps_expect(self, ord(TT_COLON), "PAR-0054", "[PAR-0054] expected ':' after field name")?;
            let field_type = ps_parse_type(self)?;
            ps_expect(self, ord(TT_SEMI), "PAR-0055", "[PAR-0055] expected ';' after field declaration")?;
            let fd = new FieldDecl(token_ident_text(field_name) as string, field_type);
            ptr_vec_push(fields as VectorBase*, fd as void*);
        }

        ps_expect(self, ord(TT_RBRACE), "PAR-0056", "[PAR-0056] expected '}' after struct body")?;
        let result = new StructDecl(token_ident_text(name_tok) as string, fields as VectorBase*, ps_extend_span(self, start));
        fields = null;
        return result;
    }
}

func ps_parse_enum(self: ParserState*) -> EnumDecl*? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_ENUM), "PAR-0060", "[PAR-0060] expected 'enum'")?;
    let name_tok = ps_expect_ident(self, "PAR-0061", "[PAR-0061] expected enum name")?;
    ps_expect(self, ord(TT_LBRACE), "PAR-0062", "[PAR-0062] expected '{' after enum name")?;

    with (let variants: VectorBase*? = ptr_vec_create(4) => _free_enum_variant_vec_opt(variants)) {
        while (!ps_check(self, ord(TT_RBRACE))) {
            let var_name_tok = ps_expect_ident(self, "PAR-0063", "[PAR-0063] expected variant name")?;

            with (let fields: VectorBase*? = ptr_vec_create(2) => _free_field_decl_vec_opt(fields)) {
                if (ps_match(self, ord(TT_LPAREN))) {
                    if (!ps_check(self, ord(TT_RPAREN))) {
                        while (true) {
                            let fname = ps_expect_ident(self, "PAR-0064", "[PAR-0064] expected variant field name")?;
                            ps_expect(self, ord(TT_COLON), "PAR-0065", "[PAR-0065] expected ':'")?;
                            let ftype = ps_parse_type(self)?;
                            let fd = new FieldDecl(token_ident_text(fname) as string, ftype);
                            ptr_vec_push(fields as VectorBase*, fd as void*);
                            if (!ps_match(self, ord(TT_COMMA))) {
                                break;
                            }
                        }
                    }
                    ps_expect(self, ord(TT_RPAREN), "PAR-0066", "[PAR-0066] expected ')' after variant payload")?;
                }

                ps_expect(self, ord(TT_SEMI), "PAR-0067", "[PAR-0067] expected ';' after variant")?;
                let variant = new EnumVariant(token_ident_text(var_name_tok) as string, fields as VectorBase*);
                ptr_vec_push(variants as VectorBase*, variant as void*);
                fields = null;
            }
        }

        ps_expect(self, ord(TT_RBRACE), "PAR-0068", "[PAR-0068] expected '}' after enum body")?;
        let result = new EnumDecl(token_ident_text(name_tok) as string, variants as VectorBase*, ps_extend_span(self, start));
        variants = null;
        return result;
    }
}

func ps_parse_type_alias(self: ParserState*) -> TypeAliasDecl*? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_TYPE), "PAR-0070", "[PAR-0070] expected type name")?;
    let name_tok = ps_expect_ident(self, "PAR-0071", "[PAR-0071] expected type alias name")?;
    ps_expect(self, ord(TT_EQ), "PAR-0072", "[PAR-0072] expected '=' in type alias")?;
    let parsed = ps_parse_type(self)?;
    with (let target: TypeRef*? = parsed => _free_type_ref_opt(target)) {
        ps_expect(self, ord(TT_SEMI), "PAR-0073", "[PAR-0073] expected ';' after type alias")?;
        let result = new TypeAliasDecl(token_ident_text(name_tok) as string, target as TypeRef*, ps_extend_span(self, start));
        target = null;
        return result;
    }
}

func ps_parse_top_level_let(self: ParserState*) -> LetDecl*? {
    let start = ps_span_start(self);
    ps_expect(self, ord(TT_LET), "PAR-0080", "[PAR-0080] expected 'let'")?;
    let name_tok = ps_expect_variable_name(self, "PAR-0081", "[PAR-0081] expected variable name")?;

    with (let type_ref: TypeRef*? = null => _free_type_ref_opt(type_ref)) {
        if (ps_match(self, ord(TT_COLON))) {
            type_ref = ps_parse_type(self)?;
        }

        ps_expect(self, ord(TT_EQ), "PAR-0082", "[PAR-0082] expected '=' in let binding")?;
        let value = ps_parse_expr(self)?;
        ps_expect(self, ord(TT_SEMI), "PAR-0083", "[PAR-0083] expected ';' after let declaration")?;

        let result = new LetDecl(token_ident_text(name_tok) as string, type_ref, value, ps_extend_span(self, start));
        type_ref = null;
        return result;
    }
}

func ps_parse_top_level_decl(self: ParserState*) -> TopLevelDecl*? {
    if (ps_check(self, ord(TT_EXTERN))) {
        let decl = ps_parse_extern_func(self)?;
        return new TopLevelDecl(TD_FUNC, decl as void*);
    }
    if (ps_check(self, ord(TT_FUNC))) {
        let decl = ps_parse_function(self, false)?;
        return new TopLevelDecl(TD_FUNC, decl as void*);
    }
    if (ps_check(self, ord(TT_STRUCT))) {
        let decl = ps_parse_struct(self)?;
        return new TopLevelDecl(TD_STRUCT, decl as void*);
    }
    if (ps_check(self, ord(TT_ENUM))) {
        let decl = ps_parse_enum(self)?;
        return new TopLevelDecl(TD_ENUM, decl as void*);
    }
    if (ps_check(self, ord(TT_TYPE))) {
        let decl = ps_parse_type_alias(self)?;
        return new TopLevelDecl(TD_TYPE_ALIAS, decl as void*);
    }
    if (ps_check(self, ord(TT_LET))) {
        let decl = ps_parse_top_level_let(self)?;
        return new TopLevelDecl(TD_LET, decl as void*);
    }

    ps_set_error(self, "PAR-0020", concat3_s("[PAR-0020] unexpected token in top level: ", token_to_string(ps_peek(self)), ""), ps_peek(self));
    return null;
}

func ps_parse_module(self: ParserState*) -> Module*? {
    let start = ps_span_start(self);

    ps_expect(self, ord(TT_MODULE), "PAR-0310", "[PAR-0310] expected 'module'")?;

    let first_mod = ps_expect_ident(self, "PAR-0311", "[PAR-0311] expected module name")?;
    let first_text = token_ident_text(first_mod) as string;
    let module_name = parse_dotted_name_rest(self, first_text)?;

    ps_expect(self, ord(TT_SEMI), "PAR-0312", "[PAR-0312] expected ';' after module name")?;

    with (let imports: VectorBase*? = ptr_vec_create(4) => _free_import_vec_opt(imports),
          let decls: VectorBase*? = ptr_vec_create(8) => _free_top_level_decl_vec_opt(decls)) {
        while (ps_match(self, ord(TT_IMPORT))) {
            let first = ps_expect_ident(self, "PAR-0320", "[PAR-0320] expected imported module name")?;
            let first_imp = token_ident_text(first) as string;
            let imp_name = parse_dotted_name_rest(self, first_imp)?;
            ps_expect(self, ord(TT_SEMI), "PAR-0321", "[PAR-0321] expected ';' after import")?;
            let imp = new Import(imp_name);
            ptr_vec_push(imports as VectorBase*, imp as void*);
        }

        while (!ps_at_end(self)) {
            let decl = ps_parse_top_level_decl(self)?;
            ptr_vec_push(decls as VectorBase*, decl as void*);
        }

        let result = new Module(module_name, imports as VectorBase*, decls as VectorBase*, ps_extend_span(self, start), self.filename);
        imports = null;
        decls = null;
        return result;
    }
}

/* ------------------------------------
   Public API
   ------------------------------------ */

func parse_module_tokens(tokens: TokenVector, filename: string) -> ParseResult* {
    let ps = ps_create(tokens, filename);
    let mod = ps_parse_module(ps);

    let result = new ParseResult(
        mod,
        ps.expr_arena,
        ps.stmt_arena,
        ps.pattern_arena,
        ps.error
    );

    ps_destroy(ps);
    return result;
}

func ps_lex_error_result(ls: LexerState*, filename: string) -> ParseResult* {
    let expr_ar = expr_arena_create(1);
    let stmt_ar = stmt_arena_create(1);
    let pat_ar = pattern_arena_create(1);

    let err_state = ParseNoError;
    match (ls.error) {
        NoError => {
            err_state = ParseHasError(ParseError("PAR-0000", "unknown parse/lex error", ls.line, ls.column, filename));
        }
        Error(code, message) => {
            err_state = ParseHasError(ParseError(code, message, ls.line, ls.column, filename));
        }
    }

    let result = new ParseResult(null, expr_ar, stmt_ar, pat_ar, err_state);
    drop ls;
    return result;
}

func ps_tokens_result(ls: LexerState*, toks: TokenVector, filename: string) -> ParseResult* {
    let result = parse_module_tokens(toks, filename);
    tv_free(toks);
    drop ls;
    return result;
}

func parse_module_source(source: string, filename: string) -> ParseResult* {
    let ls = ls_create(source, filename);
    let toks = tokenize(ls);
    if (toks == null) {
        return ps_lex_error_result(ls, filename);
    }
    return ps_tokens_result(ls, toks as TokenVector, filename);
}
